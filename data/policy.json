[
  {
    "folder_id": "1",
    "name": "大师系列",
    "children": [
      {
        "id": "5c34093efa25f1000a07660c",
        "name": "彼得林奇PEG价值选股策略",
        "code": "'''\r\n策略名称: 彼得林奇PEG价值选股策略\r\n作者: edward07t\r\n\r\n策略思路:\r\n1.选择PEG < 0.5, 即稳定成长且价值被低估的股票\r\n  其中PEG = PE / growth_rate\r\n2.使用ES风险平价配权\r\n3.根据组合的日内波动小于3%的条件, 与货币基金组合配资\r\n4.最大持仓5只股票和1只货币基金, 优先买入市值小的, 15天调仓一次\r\n5.剔除了周期性和项目类行业(该部分对改善回撤有明显的效果)\r\n'''\r\n\r\nimport pandas as pd\r\nimport numpy as np\r\nimport datetime as dt\r\n\r\ndef init(context):\r\n    # 当前持仓数：0\r\n    context.num = 0\r\n    # 最大持仓股票数：5\r\n    context.stock_max_num = 5\r\n    \r\n    # 每只股票的最大风险敞口\r\n    context.risk_limit = 0.03 / context.stock_max_num\r\n    \r\n    # 已持仓天数：0天\r\n    # 持仓周期：15天\r\n    context.hold_days, context.hold_cycle = 0, 15\r\n    \r\n    # 计算ES的置信度\r\n    context.confidenceLevel = 0.05\r\n    # 计算ES的历史回测长度\r\n    context.lag = 180\r\n    \r\n    # 每个交易日09:31运行\r\n    run_daily(func=fun_main, reference_security='000001.SZ')\r\n\r\n    \r\n######################  主函数 \r\ndef fun_main(context, bar_dict):\r\n    flag = fun_needRebalance(context)\r\n    \r\n    if flag:\r\n        last_date = get_last_datetime().strftime('%Y%m%d')\r\n        universe = list(get_all_securities('stock', date = last_date).index)\r\n        # stock_list = universe\r\n        stock_list = fun_unpaused(universe,bar_dict)\r\n        stock_list = fun_remove_new(stock_list, 60)\r\n        stock_list = fun_remove_periodic_industry(stock_list, last_date)\r\n        \r\n\r\n        line = '###############' + str(last_date) + ': ' + str(len(universe)) + ' / ' + str(len(stock_list))\r\n        print(line)\r\n\r\n        # 计算单季度增长率\r\n        df_growth = fun_cal_growth_rate(bar_dict, stock_list, last_date)\r\n\r\n        # 计算PEG\r\n        df_all = fun_cal_PEG(bar_dict, df_growth.copy(), last_date)\r\n\r\n        # 选股\r\n        buy_list = fun_get_buy_list(context, bar_dict, df_all.copy(), context.stock_max_num, last_date)\r\n\r\n        # 计算股票权重\r\n        stock_weight = fun_cal_stock_weight(buy_list, context.lag, context.confidenceLevel, last_date, 'ES')\r\n        print('stock_weight: ')\r\n        print(stock_weight)\r\n        \r\n        bond_weight = {'511880.OF': 1.0}\r\n        \r\n        # 计算最终权重（考虑组合风险 + 债券）\r\n        trade_ratio = fun_cal_position(context, bar_dict, stock_weight, bond_weight)\r\n        \r\n        print('trade_ratio: ')\r\n        print(trade_ratio)\r\n        \r\n        # 下单\r\n        fun_do_trade(context, bar_dict, trade_ratio)\r\n\r\n    context.num = len(context.portfolio.stock_account.positions)\r\n\r\n\r\ndef handle_bar(context,bar_dict):\r\n    pass\r\n\r\n\r\n#### 1.判断是否调仓函数 #########################################\r\ndef fun_needRebalance(context):\r\n    # 条件1: 持仓股数为0时，重新调仓\r\n    if context.num == 0:\r\n        context.hold_days = 0\r\n        return True\r\n    \r\n    # 条件2：持仓到调仓周期时，重新调仓\r\n    elif context.hold_days == context.hold_cycle:\r\n        context.hold_days = 0\r\n        return True\r\n    \r\n    else:\r\n        context.hold_days += 1\r\n        return False\r\n\r\n\r\n#### 2.剔除停牌股票函数 #########################################\r\ndef fun_unpaused(_stock_list,bar_dict):\r\n    return [stock for stock in _stock_list if not bar_dict[stock].is_paused] \r\n    \r\n\r\n#### 3.剔除上市不到60天的新股 ###################################\r\ndef fun_remove_new(_stock_list, days):\r\n    deltaDate = get_datetime() - dt.timedelta(days)\r\n    \r\n    stock_list = []\r\n    for stock in _stock_list:\r\n        if get_security_info(stock).start_date < deltaDate:\r\n            stock_list.append(stock)\r\n    \r\n    return stock_list\r\n    \r\n\r\n#### 4.剔除周期性行业 ###########################################\r\ndef fun_remove_periodic_industry(stock_list, last_date):\r\n    \r\n    periodic_industry = [#'T0101', # 种植业与林业\r\n                         #'T0102', # 养殖业\r\n                         #'T0103', # 农产品加工\r\n                         #'T0104', # 农业服务\r\n        \r\n                         'T0201', # 煤炭开采\r\n                         'T0202', # 石油矿业开采\r\n                         'T0203', # 采掘服务\r\n                         'T0301', # 基础化学\r\n                         'T0302', # 化学制品\r\n                         'T0303', # 化工新材料\r\n                         'T0304', # 化工合成材料\r\n                         'T0401', # 钢铁\r\n                         'T0501', # 有色冶炼加工\r\n                         'T0502', # 新材料\r\n        \r\n                         'T0601', # 建筑材料\r\n                         'T0602', # 建筑装饰\r\n                         'T0701', # 通用设备\r\n                         'T0702', # 专用设备\r\n                         'T0703', # 仪器仪表\r\n                         'T0704', # 电气设备\r\n                         #'T0801', # 半导体及元件\r\n                         #'T0802', # 光学光电子\r\n                         #'T0803', # 其他电子\r\n                         #'T0804', # 电子制造\r\n                         'T0901', # 汽车整车\r\n                         'T0902', # 汽车零部件\r\n                         'T0903', # 非汽车交运\r\n                         'T0904', # 交运设备服务\r\n                         #'T1001', # 通信设备\r\n                         #'T1002', # 计算机设备\r\n                         'T1101', # 白色家电\r\n                         'T1102', # 视听器材\r\n                         #'T1201', # 饮料制造\r\n                         #'T1202', # 食品加工制造\r\n                         #'T1301', # 防止制造\r\n                         #'T1302', # 服装家纺\r\n                         #'T1401', # 造纸\r\n                         #'T1402', # 包装印刷\r\n                         #'T1403', # 家用轻工\r\n                         #'T1501', # 化学制药\r\n                         #'T1502', # 中药\r\n                         #'T1503', # 生物制品\r\n                         #'T1504', # 医药商业\r\n                         #'T1505', # 医疗器械服务\r\n                         'T1601', # 电力\r\n                         'T1602', # 燃气水务\r\n                         'T1603', # 环保工程\r\n                         'T1701', # 港口航运\r\n                         'T1702', # 公路铁路运输\r\n                         #'T1703', # 公交\r\n                         #'T1704', # 机场航运\r\n                         #'T1705', # 物流\r\n                         'T1801', # 房地产开发\r\n                         'T1802', # 园区开发\r\n        \r\n                         'T1901', # 银行\r\n                         'T1902', # 保险及其他\r\n                         'T1903', # 证券\r\n                         #'T2001', # 零售\r\n                         'T2002', # 贸易\r\n                         #'T2101', # 景点及旅游\r\n                         #'T2102', # 酒店及餐饮\r\n                         #'T2201', # 通信服务\r\n                         #'T2202', # 计算机应用\r\n                         #'T2203', # 传媒\r\n                         #'T2301', # 综合\r\n                         #'T2401'  # 国防军工\r\n                         ]\r\n    \r\n    for industry in periodic_industry:\r\n        stocks = get_industry_stocks(industry, last_date)\r\n        stock_list = list(set(stock_list).difference(set(stocks)))\r\n    \r\n    return stock_list\r\n\r\n\r\n#### 5.计算单季度增长率函数 ####################################################\r\ndef fun_cal_growth_rate(bar_dict, stock_list, last_date):\r\n    \r\n    # 计算单季度净收益函数\r\n    def fun_get_quarterly_net_profit(current_quarter, last_quarter, stock_list):\r\n        q = query(income.symbol,\r\n                  income.net_profit\r\n                 ).filter(income.symbol.in_(stock_list))\r\n\r\n        # 当季度累计净利润\r\n        df1 = get_fundamentals(q, statDate = current_quarter)\r\n        df1.columns = ['symbol', 'total_net_profit']\r\n\r\n        # 上季度累计净利润\r\n        df2 = get_fundamentals(q, statDate = last_quarter)\r\n        df2.columns = ['symbol', 'last_total_net_profit']\r\n\r\n        df = pd.merge(df1, df2, on='symbol')\r\n\r\n        # 当前单季度净利润\r\n        df['quarterly_net_profit'] = df['total_net_profit'] - df['last_total_net_profit']\r\n\r\n        del df['total_net_profit']\r\n        del df['last_total_net_profit']\r\n\r\n        return df\r\n    \r\n    ########## 获取财报季度日期 \r\n    q = query(income.symbol, \r\n              income.stat_date\r\n             ).filter(income.symbol.in_(stock_list))\r\n\r\n    df = get_fundamentals(q, date = last_date)\r\n    \r\n    df = df.sort_values(['income_stat_date'], ascending=False)\r\n    \r\n    last_statDate = df.iloc[0,1]\r\n    \r\n    # 剔除未按时公布报表的公司，避免未来函数\r\n    df[df['income_stat_date'] != last_statDate] = None\r\n    df = df.dropna()\r\n    stock_list = list(df['income_symbol'].values)\r\n\r\n    the_year = int(str(last_statDate)[0:4])\r\n    the_month = str(last_statDate)[5:7]\r\n\r\n    ########## 获取财报单季度净利润增长率\r\n    '''\r\n    quarter_1:  当季度\r\n    quarter_2:  上季度\r\n    quarter_3:  同比上季度\r\n    quarter_4:  去年上季度\r\n    '''\r\n\r\n    if the_month == '03':\r\n        # 因为一季度的报表是单季度表，所以需要单独处理\r\n        quarter_1 = str(the_year)     + 'q1'\r\n        quarter_3 = str(the_year - 1) + 'q1'\r\n\r\n        q = query(income.symbol,\r\n              income.net_profit\r\n             ).filter(income.symbol.in_(stock_list))\r\n\r\n        df1 = get_fundamentals(q, statDate = quarter_1)\r\n        df1.columns = ['symbol', 'current_net_profit']\r\n\r\n        df2 = get_fundamentals(q, statDate = quarter_3)\r\n        df2.columns = ['symbol', 'last_net_profit']\r\n\r\n    else:\r\n        if the_month == '12':\r\n            quarter_1 = str(the_year)     + 'q4'\r\n            quarter_2 = str(the_year)     + 'q3'\r\n            quarter_3 = str(the_year - 1) + 'q4'\r\n            quarter_4 = str(the_year - 1) + 'q3'\r\n\r\n        elif the_month == '09':\r\n            quarter_1 = str(the_year)     + 'q3'\r\n            quarter_2 = str(the_year)     + 'q2'\r\n            quarter_3 = str(the_year - 1) + 'q3'\r\n            quarter_4 = str(the_year - 1) + 'q2'\r\n\r\n        elif the_month == '06':\r\n            quarter_1 = str(the_year)     + 'q2'\r\n            quarter_2 = str(the_year)     + 'q1'\r\n            quarter_3 = str(the_year - 1) + 'q2'\r\n            quarter_4 = str(the_year - 1) + 'q1'\r\n\r\n        else:\r\n            print('There is something wrong with the stat_date.')\r\n\r\n        # 计算当期单季度净利润\r\n        df1 = fun_get_quarterly_net_profit(quarter_1, quarter_2, stock_list)\r\n        df1.columns = ['symbol', 'current_net_profit']\r\n\r\n        # 计算同比上期单季度净利润\r\n        df2 = fun_get_quarterly_net_profit(quarter_3, quarter_4, stock_list)\r\n        df2.columns = ['symbol', 'last_net_profit']\r\n\r\n\r\n    df_growth = pd.merge(df1, df2, on='symbol')\r\n    # 增长率单位为%\r\n    df_growth['growth_rate'] = (df_growth['current_net_profit'] / df_growth['last_net_profit'] - 1) * 100\r\n\r\n    return df_growth\r\n\r\n\r\n#### 6.计算PEG函数 ############################################################\r\ndef fun_cal_PEG(bar_dict, df_growth, last_date):\r\n    stock_list = stock_list = list(df_growth['symbol'].values)\r\n    \r\n    q = query(valuation.symbol,\r\n              valuation.pe_ttm,\r\n             ).filter(valuation.symbol.in_(stock_list))\r\n\r\n    df_pe = get_fundamentals(q, date = last_date)\r\n    df_pe.columns = ['symbol', 'pe_ttm']\r\n    \r\n    # 剔除PE值为负的股票\r\n    df_pe[df_pe['pe_ttm'] < 0] = None\r\n    df_pe = df_pe.dropna()\r\n    \r\n    # 使用中位数去极值法\r\n    df_pe = winsorize(df_pe, 'pe_ttm')\r\n    df_pe = df_pe.dropna()\r\n    \r\n    # 彼得林奇的文章中提到：增长率>50的公司，高增长不可持续\r\n    df_growth[df_growth['growth_rate'] > 50] = None\r\n    # 剔除增长率为负的公司\r\n    df_growth[df_growth['growth_rate'] <= 0] = None\r\n\r\n    df_growth = df_growth.dropna()\r\n\r\n    del df_growth['current_net_profit']\r\n    del df_growth['last_net_profit']\r\n\r\n    df_all = pd.merge(df_pe, df_growth, on='symbol')\r\n\r\n    df_all['PEG'] = df_all['pe_ttm'] / df_all['growth_rate']\r\n    \r\n    return df_all\r\n\r\n\r\n#### 7.根据PEG选股函数 ###########################################################\r\ndef fun_get_buy_list(context, bar_dict, df_all, n, last_date):\r\n    \r\n    # 获取股票市值信息函数\r\n    def fun_get_market_cap(df_selected, last_date):\r\n        stock_list = list(df_selected['symbol'].values)\r\n    \r\n        # 获取股票市值\r\n        q = query(valuation.symbol,\r\n                  valuation.market_cap\r\n                 ).filter(valuation.symbol.in_(stock_list))\r\n\r\n        df_cap = get_fundamentals(q, date = last_date)\r\n        df_cap.columns = ['symbol', 'market_cap']\r\n\r\n        df_selected = pd.merge(df_selected, df_cap, on = 'symbol')\r\n        df_selected = df_selected.sort_values(['market_cap'], ascending = True)\r\n        df_selected = df_selected.reset_index()\r\n        \r\n        del df_selected['index']\r\n        \r\n        return df_selected\r\n        \r\n        \r\n    # PEG 需小于 0.5\r\n    df_selected = df_all[df_all['PEG'] < 0.5].copy()\r\n    \r\n    # 增添股票的市值信息到df_selected\r\n    df_selected = fun_get_market_cap(df_selected.copy(), last_date)\r\n    \r\n    # 获得备选股票列表\r\n    if len(df_selected) >= n:\r\n        buy_list = list(df_selected['symbol'][:n].values)\r\n        \r\n        for i in range(n):\r\n            print(str(df_selected['symbol'][i]) + ', PEG = ' + str(df_selected['PEG'][i]))\r\n    \r\n    else:\r\n        print('新股仅： ' + str(len(df_selected)))\r\n        buy_list = list(df_selected['symbol'].values)\r\n        \r\n        for i in range(len(df_selected)):\r\n            print(str(df_selected['symbol'][i]) + ', PEG = ' + str(df_selected['PEG'][i]))\r\n        \r\n        old_stock_list = list(context.portfolio.stock_account.positions.keys())\r\n        \r\n        if '511880.OF' in old_stock_list:\r\n            old_stock_list.remove('511880.OF')\r\n        \r\n        if len(old_stock_list) > 0:\r\n        \r\n            df_growth_old = fun_cal_growth_rate(bar_dict, old_stock_list, last_date)\r\n\r\n            df_all_old = fun_cal_PEG(bar_dict, df_growth_old.copy(), last_date)\r\n\r\n            df_selected_old = df_all_old[df_all_old['PEG'] < 1.0].copy()\r\n\r\n            df_selected_old = fun_get_market_cap(df_selected_old.copy(), last_date)\r\n\r\n            old_stock_list = list(df_selected_old['symbol'].values)\r\n\r\n            i = len(buy_list)\r\n            for stock in old_stock_list:\r\n                if i < n:\r\n                    buy_list.append(stock)\r\n                    print(str(stock) + ', PEG = ' + str(df_selected_old.loc[df_selected_old['symbol'] == stock, 'PEG'].values))\r\n                    i += 1\r\n                else:\r\n                    break\r\n        \r\n        \r\n    return buy_list\r\n\r\n\r\n#### 8.计算股票仓位 ##############################################################\r\ndef fun_cal_stock_weight(stock_list, lag, alpha, last_date, flag=None):\r\n    \r\n    # 计算个股ES风险\r\n    def fun_cal_stockES(stock, lag, alpha, last_date):\r\n        \r\n        if lag * alpha < 3: \r\n            print('The size of lag is too small for the given confidence level.')\r\n        \r\n        prices = get_price(stock, start_date=None, end_date=last_date, fre_step='1d', fields=['close'], skip_paused=False, fq='pre', bar_count=lag, is_panel=0)\r\n\r\n        dailyReturns = prices.pct_change().dropna()\r\n        dailyReturns_sort = dailyReturns.sort_values(['close'], ascending=True)\r\n\r\n        num = round((lag-1) * alpha)\r\n        ES = dailyReturns_sort['close'][:num].sum() / num\r\n\r\n        return ES\r\n    \r\n    # ES风险平价配股\r\n    if flag == 'ES':\r\n        stock_position = {}\r\n        total_position = 0\r\n        for stock in stock_list:\r\n            risk = fun_cal_stockES(stock, lag, alpha, last_date)\r\n            stock_position[stock] = 1.0 / risk\r\n            total_position += stock_position[stock]\r\n\r\n        stock_real_position = {}\r\n        for stock in stock_list:\r\n            stock_real_position[stock] = stock_position[stock] / total_position\r\n    \r\n    # 等权重配股\r\n    else:\r\n        stock_real_position = {}\r\n        for stock in stock_list:\r\n            stock_real_position[stock] = 1.0 / len(stock_list)\r\n\r\n    return stock_real_position\r\n\r\n\r\n#### 9.计算加入货币基金后的资产配置 ##################################################\r\ndef fun_cal_position(context, bar_dict, stock_weight, bond_weight, position_ratio = 1.0):\r\n    \r\n    # 计算组合收益\r\n    def fun_get_portfolio_daily_return(bar_dict, stock_weight, lag=180):\r\n        \r\n        last_date = get_last_datetime().strftime('%Y%m%d')\r\n        stock_list = list(stock_weight.keys())\r\n        \r\n        df = pd.DataFrame()\r\n        for stock in stock_list:\r\n            prices = get_price(stock, start_date=None, end_date=last_date, fre_step='1d', fields=['close'], skip_paused=False, fq='pre', bar_count=lag, is_panel=0)\r\n            df[stock] = prices['close']\r\n        \r\n        df = df.pct_change().dropna()\r\n        \r\n        df['portfolio_returns'] = 0\r\n        for stock in stock_list:\r\n            df['portfolio_returns'] += df[stock] * stock_weight[stock]\r\n            del df[stock]\r\n            \r\n        df = df.sort_values(['portfolio_returns'], ascending = True)\r\n        \r\n        return df\r\n    \r\n    # 计算组合ES值\r\n    def fun_get_portfolio_ES(dailyReturns, alpha):\r\n        \r\n        lag = len(dailyReturns)\r\n        \r\n        num = round(lag * alpha)\r\n        \r\n        ES = - (dailyReturns['portfolio_returns'][:num].sum() / num)\r\n        \r\n        if ES < 0:\r\n            ES = 0\r\n        \r\n        print('ES: ' + str(ES))\r\n        \r\n        return ES\r\n    \r\n    # 计算组合VaR值\r\n    def fun_get_portfolio_VaR(dailyReturns, alpha):\r\n        \r\n        z_score = {0.05: 1.65,\r\n                   0.04: 1.75,\r\n                   0.01: 2.33,\r\n                   0.0001: 3.7}\r\n        \r\n        VaR = - (dailyReturns['portfolio_returns'].mean() - z_score[alpha] * dailyReturns['portfolio_returns'].std())\r\n        \r\n        if VaR < 0:\r\n            VaR = 0\r\n        \r\n        print('VaR: ' + str(VaR))\r\n        \r\n        return VaR\r\n        \r\n    # 计算股票组合在给定风险损失的情况下最大持仓金额    \r\n    def fun_get_equity_value(bar_dict, stock_weight, risk_money, max_risk_money, alpha, position_ratio):\r\n        \r\n        # 计算组合每日收益\r\n        df_daily_returns = fun_get_portfolio_daily_return(bar_dict, stock_weight)\r\n        \r\n        # 计算组合ES值\r\n        portfolio_ES = fun_get_portfolio_ES(df_daily_returns.copy(), alpha)\r\n        \r\n        # 计算组合VaR值\r\n        portfolio_VaR = fun_get_portfolio_VaR(df_daily_returns.copy(), alpha)\r\n        \r\n        # 组合ES和VaR风险均为0\r\n        if (portfolio_ES) == 0 and (portfolio_VaR) == 0:\r\n            equity_value = context.positions_value * position_ratio\r\n            print('组合风险评估为0， 请检查数据。')\r\n            return equity_value\r\n        \r\n        if portfolio_ES == 0:\r\n            print('ES = 0')\r\n            equity_value = risk_money / portfolio_VaR\r\n        \r\n        elif portfolio_VaR == 0:\r\n            print('VaR = 0')\r\n            equity_value = max_risk_money / portfolio_ES\r\n            \r\n        else:\r\n            equity_value = min(risk_money / portfolio_VaR, max_risk_money / portfolio_ES)\r\n    \r\n        \r\n        return equity_value\r\n        \r\n    \r\n    stock_num = len(stock_weight)\r\n    \r\n    risk_money = context.portfolio.portfolio_value * stock_num * context.risk_limit * position_ratio\r\n    max_risk_money = risk_money * 1.5\r\n    \r\n    # 股票组合在给定风险损失的情况下，最大持仓金额\r\n    stock_value = 0\r\n    if stock_weight:\r\n        stock_value = fun_get_equity_value(bar_dict, stock_weight, risk_money, max_risk_money, context.confidenceLevel, position_ratio)\r\n        \r\n    stock_ratio = 0    # 股票持仓比例\r\n    bond_ratio = 0     # 债券持仓比例\r\n    \r\n    total_value = context.portfolio.portfolio_value * position_ratio    # 最大持仓金额（包括股票和债券）\r\n    \r\n    if stock_value > total_value:\r\n        bond_ratio = 0\r\n        stock_ratio = 1.0 * position_ratio\r\n    else:\r\n        stock_ratio = (stock_value / total_value) * position_ratio\r\n        bond_ratio = (1 - (stock_value / total_value)) * position_ratio\r\n    \r\n    print('stock_value: ' + str(stock_value))\r\n    print('total_value: ' + str(total_value))\r\n    \r\n    trade_ratio = {}\r\n    for stock in stock_weight:\r\n        if stock in trade_ratio:\r\n            trade_ratio[stock] += round((stock_weight[stock] * stock_ratio), 3)\r\n        else:\r\n            trade_ratio[stock] = round((stock_weight[stock] * stock_ratio), 3)\r\n    \r\n    for stock in bond_weight:\r\n        if stock in trade_ratio:\r\n            trade_ratio[stock] += round((bond_weight[stock] * bond_ratio), 3)\r\n        else:\r\n            trade_ratio[stock] = round((bond_weight[stock] * bond_ratio), 3)\r\n    \r\n    return trade_ratio\r\n\r\n    \r\n#### 10.根据指定的仓位下单 #############################################################\r\ndef fun_do_trade(context, bar_dict, stock_position):\r\n    \r\n    for stock in list(context.portfolio.stock_account.positions.keys()):\r\n        if stock not in stock_position:\r\n            order_target_percent(stock, 0)\r\n        else:\r\n            order_target_percent(stock, stock_position[stock])\r\n    \r\n    for stock in stock_position:\r\n        if stock not in list(context.portfolio.stock_account.positions.keys()):\r\n            order_target_percent(stock, stock_position[stock])\r\n    \r\n    print('当前持仓: ')\r\n    print(list(context.portfolio.stock_account.positions.keys()))\r\n            \r\n    \r\n#### 11.中位数去极值函数 ################################################################\r\ndef winsorize(df, factor, n=20):\r\n    '''\r\n    df为bar_dictFrame数据\r\n    factor为需要去极值的列名称\r\n    n 为判断极值上下边界的常数\r\n    '''\r\n    # 提取该列的数据\r\n    ls_raw = np.array(df[factor].values)\r\n    # 排序\r\n    ls_raw.sort(axis = 0)\r\n    # 获取中位数\r\n    D_M = np.median(ls_raw)\r\n    \r\n    # 计算离差值\r\n    ls_deviation = abs(ls_raw - D_M)\r\n    # 排序\r\n    ls_deviation.sort(axis = 0)\r\n    # 获取离差中位数\r\n    D_MAD = np.median(ls_deviation)\r\n    \r\n    # 将大于中位数n倍离差中位数的值赋为NaN\r\n    df.loc[df[factor] >= D_M + n * D_MAD, factor] = None\r\n    # 将小于中位数n倍离差中位数的值赋为NaN\r\n    df.loc[df[factor] <= D_M - n * D_MAD, factor] = None\r\n    \r\n    return df",
        "status": "SUCCESS",
        "stop_run_time": "2019-01-08T10:24:24",
        "stock_market": "STOCK",
        "progress": 1,
        "inner": true,
        "simu_on": false,
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "begin_date": "2014-01-01",
        "end_date": "2018-12-31",
        "start_run_time": "2019-01-08T10:21:50",
        "frequency": "DAILY",
        "run_env": "py35",
        "modified": "2019-01-08T10:24:24",
        "style": "NORMAL",
        "created": "2019-01-08T10:21:50",
        "strategylib": true,
        "libresearchinfo": {
          "id": "5c355d2db39dc2000b7eeb99",
          "share_filename": "9dbf8b3032412be961603a481b61a6f7.ipynb",
          "user_id": "385045923",
          "path": "已完成/彼得林奇文档.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/385045923/9dbf8b3032412be961603a481b61a6f7.html",
          "clone_count": 0
        }
      },
      {
        "name": "巴菲特的alpha12",
        "id": "5c340544ac17c6000cb7e2f9",
        "begin_date": "2014-01-01",
        "code": "\"\"\"\r\n作者：qiujier\r\n\r\n在《巴菲特的alpha》文章里，后人把巴菲特的收益分成六个维度，分别是市场，估值，规模，动量，质量和波动率六个维度。我们今天就开始复现其中的原理，除去市场维度，我们从其他五个维度分别挑选因子，总共6个，组成6因子模型。  \r\n对于因子的处理，由于因子来自不同维度，所以无需进行降维或者因子正交处理来解决它的相关性问题，所以简单进行了去极值和标准化处理\r\n对于股票列表，已经进行剔除ST，上市未满60天的新股，停牌股和开盘涨停股\r\n对于打分方式：针对升序因子乘以-1；针对降序因子乘以1，最后进行叠加\r\n在择时方面，采用RSRS的方式对指数进行择时信号。\r\n资金规模在10000000，20日调仓，回测时间从2010-01-01到2018-11-08\r\n\"\"\"\r\n\r\nimport pandas as pd\r\nimport numpy as np\r\nimport datetime as dt\r\nimport talib as ta\r\nfrom datetime import date,timedelta \r\nimport statsmodels.api as sm\r\n\r\n#初始化账户\t\t\t\r\ndef init(context):\t\t\t\r\n    \t\r\n    set_params(context)\r\n    set_variables(context)\r\n    set_backtest()\r\n    run_daily(stop_loss)    \r\n        \r\n#设置策参数\r\ndef set_params(context):\r\n\r\n    g.tc = 20                               #调仓频率      \r\n    g.t=0\r\n    g.big_small = 'big'                     #big是降序，small为升序\r\n    context.stock = '000300.SH'\r\n    g.long_pct = 0.05\r\n    g.stock='000300.SH'                     #择时选取的指数\r\n    \r\n    g.total_positionprevious=0              #仓位\r\n    g.N = 18                                #RSRS选取的回归长度 \r\n    g.M = 1100                              #RSRS均值窗口 \r\n        \r\ndef set_variables(context): \r\n    \r\n    context.X_length=11 \r\n    context.flag=True\r\n    g.buy = 0.7                              #买入阀门\r\n    g.sell = -0.7                            #卖出阀门\r\n    g.ans = []\r\n    g.ans_rightdev= []\r\n    \r\ndef set_backtest():\r\n    set_benchmark('000300.SH')               # 设置基准\r\n    set_slippage(PriceSlippage(0.002))       # 设置可变滑点\r\n\r\n\r\ndef before_trading(context):\r\n    \r\n    #需要先建立过去的数据集合，否则后面新数据没有历史数据作为窗口\r\n    if context.flag:\r\n        \r\n        initlast_date=context.now-timedelta(days=1)\r\n        prices = get_price(g.stock, '2006-06-05', initlast_date, '1d', ['high', 'low'])\r\n        #获取最高价和最低价\r\n        highs = prices.high\r\n        lows = prices.low\r\n        #建立一个初始的装有beta从过去到初始阶段的历史数据的列表g.ans\r\n        g.ans = []\r\n        for i in range(len(highs))[g.N:]:\r\n            data_high = highs.iloc[i-g.N+1:i+1]\r\n            data_low = lows.iloc[i-g.N+1:i+1]\r\n            X = sm.add_constant(data_low)\r\n            model = sm.OLS(data_high,X)\r\n            results = model.fit()\r\n            g.ans.append(results.params[1])\r\n        \r\n            # 装有rsquare从过去到初始阶段历史数据的列表    \r\n            g.ans_rightdev.append(results.rsquared)\r\n        context.flag=False\r\n\r\n\r\n#个股止损\r\ndef stop_loss(context,bar_dict):\r\n    for stock in list(context.portfolio.positions):\r\n        cumulative_return=bar_dict[stock].close/context.portfolio.positions[stock].cost_basis\r\n        if cumulative_return<0.9:\r\n            order_target_value(stock,0)\r\n        \r\n\r\n\r\n\r\ndef handle_bar(context,bar_dict):\t\r\n    \r\n    stock = g.stock\r\n    beta=0\r\n    r2=0\r\n    \r\n    prices = history(stock,['high', 'low'], g.N, '1d', False, 'pre', is_panel=1)\r\n    highs = prices.high\r\n    lows = prices.low\r\n    X = sm.add_constant(lows)\r\n    model = sm.OLS(highs, X)\r\n    #得到beta\r\n    beta = model.fit().params[1]\r\n    #将新的beta添加到装有历史数据列表\r\n    g.ans.append(beta)\r\n    #得到rsquare数据\r\n    r2=model.fit().rsquared\r\n    #将新的rsquare添加到装有历史数据列表\r\n    g.ans_rightdev.append(r2)\r\n    \r\n    \r\n    \r\n    #为了标准化当下的beta数值，拿过去1100天的数据作为均值的窗口\r\n    section = g.ans[-g.M:]\r\n    # 计算均值序列\r\n    mu = np.mean(section)\r\n    # 计算标准化RSRS指标序列\r\n    sigma = np.std(section)\r\n    zscore = (section[-1]-mu)/sigma  \r\n    #计算右偏RSRS标准分，就是将标准化后的beta数据乘以原始beta再乘以拟合度\r\n    zscore_rightdev= zscore*beta*r2\r\n    \r\n    #根据交易信号买入卖出\r\n    if zscore_rightdev > g.buy:\r\n        total_position=1\r\n    \r\n    elif zscore_rightdev < g.sell:\r\n        total_position=0     \r\n    else:\r\n        total_position=g.total_positionprevious\r\n    \r\n    \r\n    \r\n    \r\n    if (g.total_positionprevious != total_position) or (g.t%g.tc==0):\r\n        g.total_positionprevious=total_position\r\n        \r\n        last_date=get_last_datetime().strftime('%Y%m%d')\r\n        stock_list=list(get_all_securities('stock',date=last_date).index)\r\n        \r\n        #对stock_list进行去除st，停牌等处理\r\n        stock_list=fun_unpaused(bar_dict, stock_list)\r\n        stock_list=fun_st(bar_dict,stock_list)\r\n        stock_list=fun_highlimit(bar_dict,stock_list)\r\n        stock_list=fun_remove_new(stock_list, 60)\r\n        \r\n        #以下是各单因子\r\n        #规模因子\r\n        cap_df = market_cap(stock_list, 'valuation_market_cap',last_date)\r\n        cap_df = cap_df * -1\r\n        \r\n        #估值因子\r\n        PB_df = PB(stock_list, 'valuation_pb',last_date)\r\n        PB_df = PB_df * -1\r\n        \r\n        #动量因子\r\n        MTM20_df = MTM20(stock_list, 'MTM20')\r\n        MTM20_df=MTM20_df* -1\r\n        #质量因子\r\n        #1.ROE（高利润）\r\n        roe_df = roe(stock_list, 'profit_roe_ths',last_date)\r\n        \r\n        #2.净利润同比增长率（高成长）\r\n        net_profit_growth_ratio_df=net_profit_growth_ratio(stock_list,'growth_net_profit_growth_ratio',last_date)\r\n        \r\n        #波动率因子\r\n        ATR20_df = ATR20(stock_list, 'ATR20')\r\n        ATR20_df = ATR20_df * -1\r\n\r\n\r\n\r\n        #合并多因子\r\n        concat_obj = [cap_df, PB_df,MTM20_df,roe_df,net_profit_growth_ratio_df,ATR20_df]\r\n        df = pd.concat(concat_obj, axis=1)\r\n        df = df.dropna()\r\n#       log.info(type(df))\r\n        sum = df.sum(axis=1)\r\n        #log.info(sum)\r\n\r\n\r\n        #进行排序\r\n        if g.big_small == 'big':\r\n            # 按照大排序\r\n            sum.sort_values(ascending = False,inplace=True)\r\n        if g.big_small == 'small':\r\n            # 按照小排序\r\n            sum.sort_values(ascending = True,inplace=True)\r\n        # 根据比例取出排序后靠前部分\r\n        \r\n        stock_list1 = sum[0:int(len(stock_list)*g.long_pct)].index\r\n        \r\n        #log.info(stock_list1)\r\n        buy_list = []\r\n        \r\n        for stock in stock_list1:\r\n            buy_list.append(stock)\r\n            \r\n        #买卖操作\r\n        for stock in list(context.portfolio.positions):\r\n            if stock not in buy_list:\r\n                order_target(stock, 0)\r\n                \r\n        cash = context.portfolio.portfolio_value\r\n        position=cash*g.total_positionprevious\r\n #       position=cash*g.SAR_signal\r\n        num=int(len(stock_list)*g.long_pct)\r\n        ## 买入\r\n      \r\n        for stock in buy_list:\r\n            order_target_value(stock,position/num)\r\n            \r\n\r\n        \r\n    g.t=g.t+1\r\n\r\n\"\"\"\r\n以下是单因子\r\n\"\"\"    \r\ndef market_cap(stocklist, factor,last_date):\r\n    \r\n    # 取数据\r\n    df = get_fundamentals(query(valuation.symbol, valuation.market_cap).filter(valuation.symbol.in_(stocklist)),date=last_date)\r\n    #log.info(df)\r\n\r\n    df = df.set_index('valuation_symbol')\r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(factor, after_MAD)\r\n    \r\n    return after_zscore    \r\n    \r\ndef PB(stocklist, factor,last_date):\r\n    # 取数据\r\n    df = get_fundamentals(query(valuation.symbol, valuation.pb).filter(valuation.symbol.in_(stocklist)),date=last_date)\r\n    df = df.set_index('valuation_symbol')\r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(factor, after_MAD)\r\n    \r\n    return after_zscore\r\n\r\n\r\n\r\ndef MTM20(stocklist, factor):\r\n    # 取数据\r\n    for stock in stocklist:\r\n        df1=history(stock,['close'],20,'1d') \r\n    #    log.info(df1)\r\n        \r\n        s = pd.DataFrame([(df1['close'][-1]-df1['close'][0])/df1['close'][0]], index=[stock])\r\n    #    log.info(s)\r\n        if 'df' in locals():\r\n            df = df.append(s)\r\n        else:\r\n            df = s\r\n    #log.info(df)\r\n    df.columns = ['MTM20']\r\n    df.index.name = 'valuation_symbol'\r\n    \r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(factor, after_MAD)\r\n    \r\n    return after_zscore\r\n\r\n\r\ndef roe(stocklist, factor,last_date):\r\n    # 取数据\r\n    df = get_fundamentals(query(valuation.symbol, profit.roe_ths).filter(valuation.symbol.in_(stocklist)),date=last_date)\r\n#    log.info(df)\r\n    df = df.set_index('valuation_symbol')\r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(factor, after_MAD)\r\n    \r\n    return after_zscore   \r\n\r\n\r\n\r\ndef net_profit_growth_ratio(stocklist, factor,last_date):\r\n    # 取数据\r\n    df = get_fundamentals(query(valuation.symbol, growth.net_profit_growth_ratio).filter(valuation.symbol.in_(stocklist)),date=last_date)\r\n#    log.info(df)\r\n    df = df.set_index('valuation_symbol')\r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(factor, after_MAD)\r\n    \r\n    return after_zscore   \r\n\r\ndef ATR20(stocklist, new_factor):\r\n    # 取数据\r\n    for stock in stocklist:\r\n        Data_ATR = history(stock,['close','high','low'],20,'1d')\r\n        close_ATR = np.array(Data_ATR['close'])\r\n        high_ATR = np.array(Data_ATR['high'])\r\n        low_ATR = np.array(Data_ATR['low'])\r\n        '''\r\n        if np.isnan(close_ATR).any():\r\n            continue\r\n        '''    \r\n        ATR = ta.ATR(high_ATR, low_ATR, close_ATR, timeperiod=1)\r\n     \r\n        indices = ~np.isnan(ATR)\r\n        result = np.average(ATR[indices])\r\n        s = pd.Series(result.astype(float), index=[stock])\r\n        if 'ATR_df' in locals():\r\n            ATR_df = ATR_df.append(s)\r\n        else:\r\n            ATR_df = s\r\n    df = ATR_df.to_frame()\r\n    df.index.name = 'valuation_symbol'\r\n    df.columns = [new_factor]\r\n    # 绝对中位数法取极值\r\n    after_MAD = MAD(new_factor, df)\r\n    # z-score法标准化\r\n    after_zscore = zscore(new_factor, after_MAD)\r\n    \r\n    return after_zscore\r\n\r\n\"\"\"\r\n以下是进行因子数据处理，对因子进行MAD去极值，以及标准化处理\r\n\"\"\"    \r\ndef MAD(factor, df):\r\n    # 取得中位数\r\n    median = df[factor].median()\r\n    # 取得数据与中位数差值\r\n    df1 = df-median\r\n    # 取得差值绝对值\r\n    df1 = df1.abs()\r\n    # 取得绝对中位数\r\n    MAD = df1[factor].median()\r\n    # 得到数据上下边界\r\n    extreme_upper = median + 3 * 1.483 * MAD\r\n    extreme_lower = median - 3 * 1.483 * MAD\r\n    # 将数据上下边界外的数值归到边界上\r\n    df.ix[(df[factor]<extreme_lower), factor] = extreme_lower\r\n    df.ix[(df[factor]>extreme_upper), factor] = extreme_upper\r\n    \r\n    return df\r\n\r\n\r\n\r\n# z-score标准化\r\ndef zscore(factor, df):\r\n    # 取得均值\r\n    mean = df[factor].mean()\r\n    # 取得标准差\r\n    std = df[factor].std()\r\n    # 取得标准化后数据\r\n    df = (df - mean) / std\r\n    \r\n    return df    \r\n\r\n\"\"\"\r\n以下对股票列表进行去除ST，停牌，去新股，以及去除开盘涨停股\r\n\"\"\"   \r\n#去除开盘涨停股票\r\ndef fun_highlimit(bar_dict,stock_list):\r\n    return [stock for stock in stock_list if bar_dict[stock].open!=bar_dict[stock].high_limit]\r\n\r\n#去除st股票\r\ndef fun_st(bar_dict,stock_list): \r\n    return [stock for stock in stock_list if not bar_dict[stock].is_st]\r\n\r\n\r\n \r\ndef fun_unpaused(bar_dict, stock_list):\r\n\r\n    return [s for s in stock_list if not bar_dict[s].is_paused]     \r\n\r\n\r\ndef fun_remove_new(_stock_list, days):\r\n    \r\n    deltaDate = get_datetime() - dt.timedelta(days)\r\n        \r\n    stock_list = []\r\n    for stock in _stock_list:\r\n        if get_security_info(stock).listed_date < deltaDate:\r\n            stock_list.append(stock)\r\n        \r\n    return stock_list        \r\n\r\n",
        "capital_base": 1000000,
        "run_env": "py35",
        "modified": "2019-01-08T10:23:35",
        "end_date": "2018-12-31",
        "algo_gen_method": "MANUAL",
        "created": "2019-01-08T10:04:52",
        "style": "NORMAL",
        "simu_on": false,
        "stock_market": "STOCK",
        "start_run_time": "2019-01-08T10:04:52",
        "status": "SUCCESS",
        "inner": true,
        "stop_run_time": "2019-01-08T10:23:35",
        "frequency": "DAILY",
        "progress": 1,
        "strategylib": true
      },
      {
        "name": "奥肖内西价值投资法",
        "id": "5c340089e052f2000b4b1094",
        "created": "2019-01-08T09:44:41",
        "modified": "2019-01-08T09:48:54",
        "inner": true,
        "frequency": "DAILY",
        "stock_market": "STOCK",
        "simu_on": false,
        "algo_gen_method": "MANUAL",
        "progress": 1,
        "start_run_time": "2019-01-08T09:44:41",
        "begin_date": "2014-01-01",
        "end_date": "2018-12-31",
        "stop_run_time": "2019-01-08T09:48:54",
        "capital_base": 1000000,
        "status": "SUCCESS",
        "style": "NORMAL",
        "code": "'''\r\n詹姆斯.奥肖内西价值投资法\r\n作者：warrior_f\r\n\r\n策略选股\r\nA. 股票的市值大于市场的中位数\r\nB. 股票的股本大于市场的中位数\r\nC. 股票的市现率大于0，从小到大排列，取前400只股票\r\nD. 股票的市销率大于0，从小到大排列，取前400只股票\r\nE. 股票的股息率从大到小排列，取前400只股票\r\nF. 取上述5个条件满足下的前30只股票\r\n交易方式：按月调仓\r\n止损方式\r\nA. 当个股价格低于成本价的7%时，卖出该股票\r\nB. 当5日内大盘下跌13%时，卖出所有股票\r\n\r\n'''\r\nfrom datetime import timedelta, date\r\nimport pandas as pd\r\n\r\n############################## 以下为主要函数  ################################\r\n# 初始化函数 ##################################################################\r\n\r\ndef init(context):\r\n    # 设置手续费为交易额的0.02%，最少5元\r\n    set_commission(PerShare(type='stock', cost=0.0003, min_trade_cost=5.0))\r\n    # 设置可变滑点，买入成交价 = 委托价 * (1 + 0.1%)，卖出成交价 = 委托价 * (1 - 0.1%);\r\n    set_slippage(PriceSlippage(0.002))\r\n    context.selected = 400\r\n    context.n = 30 # 持股数\r\n    context.trade_date = range(1,13,1)\r\n    ## 按月调用程序\r\n    run_monthly(trade,date_rule=-1)\r\n    \r\n# 月末调仓函数 #################################################################\r\ndef trade(context, bar_dict):\r\n    date = get_datetime()\r\n    months = get_datetime().month\r\n    if months in context.trade_date:\r\n       \r\n        \r\n        ##获得购买股票列表\r\n        market_cap_list = stocks_market_cap(context, bar_dict)\r\n        PCF_list = stocks_PCF(context, bar_dict)\r\n        PS_list = stocks_PS(context, bar_dict)\r\n        capitalization_list = stocks_capitalization(context, bar_dict)\r\n        DY_list = stocks_DY(context, bar_dict)\r\n        ## 获得满足每种条件的股票池\r\n        stock_list = list(set(market_cap_list)&set(PCF_list)&set(PS_list)&set(capitalization_list)&set(DY_list))\r\n        log.info(len(stock_list))\r\n        \r\n        ## 卖出\r\n        if len(context.portfolio.positions) > 0:\r\n            for stock in list(context.portfolio.positions):\r\n                if stock not in stock_list:\r\n                    order_target(stock, 0)\r\n        ## 买入\r\n        if len(stock_list) > 0:\r\n            for stock in stock_list:\r\n                if stock not in list(context.portfolio.positions):\r\n                    if len(context.portfolio.positions) < context.n :\r\n                        number = context.n  - len(context.portfolio.positions)\r\n                        order_value(stock,context.portfolio.available_cash/number)\r\n                    else: \r\n                        order_value(stock,context.portfolio.available_cash)\r\n                           \r\n    else:\r\n        pass\r\n\r\n# 每日检查止损条件 #############################################################  \r\ndef handle_bar(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    \r\n    if len(context.portfolio.positions) > 0:\r\n        # 止损：个股跌幅超过8%，卖出\r\n        securities = list(context.portfolio.positions)\r\n        for stock in securities:\r\n            price = history(stock, ['close'], 1, '1d', False,'pre')\r\n            if context.portfolio.positions[stock].cost_basis/price['close'][0]-1 < -0.08:\r\n                order_target(stock, 0)\r\n                #log.info('%s 止损：%s' %(last_date,stock))\r\n                \r\n        #止损：5天内大盘下跌13%，卖出\r\n        price_bench = history('000300.SH', ['close'], 5, '1d', False,'pre')\r\n        if price_bench['close'][-5]/price_bench['close'][-1]-1 > 0.13:\r\n            if len(list(context.portfolio.positions))>0:\r\n                for stock in list(context.portfolio.positions):\r\n                    order_target(stock, 0)\r\n\r\n################## 以下为功能函数, 在主要函数中调用 ##########################\r\n\r\n# 1 根据市值来筛选股票列表\r\ndef stocks_market_cap(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    market_cap = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.market_cap\r\n        ).order_by(\r\n            valuation.market_cap.desc()\r\n        ),date = last_date)\r\n    length = len(market_cap)\r\n    market_cap = market_cap[:int(length/2)]\r\n    return list(market_cap['valuation_symbol'])\r\n\r\n# 2. 根据股本来筛选股票列表\r\ndef stocks_capitalization(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    capitalization = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.capitalization\r\n        ).order_by(\r\n            valuation.capitalization.desc()\r\n        ),date = last_date)\r\n    length = len(capitalization)\r\n    capitalization = capitalization[:int(length/2)]\r\n    return list(capitalization['valuation_symbol'])\r\n\r\n# 3. 根据市现率来筛选股票列表\r\ndef stocks_PCF(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    PCF = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.pcf\r\n        ).filter(\r\n            valuation.pcf > 0\r\n        ).order_by(\r\n            valuation.pcf.asc()\r\n        ).limit(\r\n            context.selected\r\n        ),date = last_date)\r\n    return list(PCF['valuation_symbol'])\r\n\r\n# 4. 根据市销率来筛选股票列表\r\ndef stocks_PS(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    PS = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.ps\r\n        ).filter(\r\n            valuation.ps>0\r\n        ).order_by(\r\n            valuation.ps.asc()      \r\n        ),date = last_date)\r\n    return list(PS['valuation_symbol'])\r\n\r\n# 5. 根据股息率（每股收益/每股市价代替）来筛选股票列表\r\n\r\ndef stocks_DY(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    EPS = get_fundamentals(query(\r\n        income.symbol,\r\n        income.basic_eps\r\n    ),date = last_date)\r\n    stock_List = list(EPS['income_symbol'])\r\n    close_price = history(stock_List,['close'],1,'1d',True,None)\r\n    DY_stock = dict(zip(EPS['income_symbol'],EPS['income_basic_eps']))\r\n    log.info(len(DY_stock)-len(EPS['income_symbol']))\r\n    for stock in stock_List:\r\n        try:\r\n            DY_stock[stock] = DY_stock[stock]/close_price[stock]['close'][0]\r\n        except:\r\n            DY_stock[stock] = 0\r\n    \r\n    DY_stock = sorted(DY_stock.items(),key=lambda t:t[1],reverse=True)    \r\n    return list(dict(DY_stock[:context.selected]).keys())",
        "run_env": "py35",
        "strategylib": true
      },
      {
        "name": "查尔斯.布兰德价值投资策略",
        "id": "5c34020775019f000c97f7b3",
        "code": "'''\r\n\r\n查尔斯.布兰德价值投资策略\r\n作者：warrior_f\r\n\r\n策略选股\r\nA. 股票负债净值比小于80%\r\nB. 股票的市盈率不高于市场平均值1.5 倍\r\nC. 股票的股价/近四季现金流量（市现率）不高于市场平均值的1.5 倍\r\nD. 股票的市净率不高于市场平均值的1.5 倍\r\nE. 股票的市净率小于2.0 倍\r\nF. 满足于上述条件下的前30只股票\r\n\r\n交易方式：按月调仓\r\n止损方式 \r\nA. 当个股价格低于成本价的7%时，卖出该股票\r\nB. 当5日内大盘下跌13%时，卖出所有股票\r\n\r\n\r\n'''\r\nfrom datetime import timedelta, date\r\nimport pandas as pd\r\n############################## 以下为主要函数  ################################\r\n# 初始化函数 ##################################################################\r\n\r\ndef init(context):\r\n    # set_commission(PerTrade(cost=0.0003, min_trade_cost=5))\r\n    # set_slippage(PriceRelatedSlippage())\r\n    context.selected = 400\r\n    #设置持仓的数量\r\n    context.n = 30 \r\n    #月度调仓\r\n    context.trade_date = range(1,13,1)\r\n    #交易按月运行\r\n    run_monthly(trade,date_rule=-1)\r\n# 月末调仓函数 #################################################################\r\ndef trade(context, bar_dict):\r\n    months = get_datetime().month\r\n    log.info(months)\r\n    if months in context.trade_date: \r\n        \r\n        ##获得购买股票列表\r\n        PE_list = stocks_PE(context, bar_dict)\r\n        PB_list = stocks_PB(context, bar_dict)\r\n        PCF_ttm_list = stocks_PCF_ttm(context, bar_dict)\r\n        Debt_asset_list = stocks_Debt_asset(context, bar_dict)\r\n        stock_list = list(set(PE_list)&set(PB_list)&set(PCF_ttm_list)&set(Debt_asset_list))\r\n        \r\n        ## 卖出股票\r\n        if len(context.portfolio.positions) > 0:\r\n            for stock in list(context.portfolio.positions):\r\n                if stock not in stock_list:\r\n                    order_target(stock, 0)\r\n        ## 买入股票\r\n        if len(stock_list) > 0:\r\n            for stock in stock_list:\r\n                if stock not in list(context.portfolio.positions):\r\n                    if len(context.portfolio.positions) < context.n :\r\n                        number = context.n  - len(context.portfolio.positions)\r\n                        order_value(stock,context.portfolio.available_cash/number)\r\n                    else: \r\n                        order_value(stock,context.portfolio.available_cash)\r\n                           \r\n    else:\r\n        pass\r\n# 每日检查止损条件 #############################################################  \r\ndef handle_bar(context, bar_dict):\r\n    \r\n    ## 个股止损\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    \r\n    if len(context.portfolio.positions) > 0:\r\n        # 止损：个股跌幅超过8%，卖出\r\n        securities = list(context.portfolio.positions)\r\n        for stock in securities:\r\n            price = history(stock, ['close'], 1, '1d', False,'pre')\r\n            if context.portfolio.positions[stock].cost_basis/price['close'][0]-1 < -0.08:\r\n                order_target(stock, 0)\r\n                #log.info('%s 止损：%s' %(last_date,stock))\r\n                \r\n        #止损：5天内大盘下跌13%，卖出\r\n        price_bench = history('000300.SH', ['close'], 5, '1d', False,'pre')\r\n        if price_bench['close'][-5]/price_bench['close'][-1]-1 > 0.13:\r\n            if len(list(context.portfolio.positions))>0:\r\n                for stock in list(context.portfolio.positions):\r\n                    order_target(stock, 0)\r\n                    #log.info('%s 大盘下跌' %(last_date))\r\n\r\n################## 以下为功能函数, 在主要函数中调用 ##########################       \r\n# 1. 根据PE因子选出的股票列表\r\ndef stocks_PE(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    PE = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.pe\r\n        ).filter(\r\n            valuation.pe > 0,\r\n        ).order_by(\r\n            valuation.pe.asc()\r\n        ),date = last_date)\r\n    PE_limit = PE['valuation_pe'].mean()*1.5\r\n    PE = PE[PE['valuation_pe']<=PE_limit]\r\n    #log.info(PE)\r\n    return list(PE['valuation_symbol'])\r\n# 2. 根据PB因子选出的股票列表\r\ndef stocks_PB(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    PB = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.pb\r\n        ).filter(\r\n            valuation.pb > 0,\r\n            valuation.pb < 2\r\n        ).order_by(\r\n            valuation.pb.asc()\r\n        ),date = last_date)\r\n    PB_limit = PB['valuation_pb'].mean()*1.5\r\n    PB = PB[PB['valuation_pb']<=PB_limit]\r\n    return list(PB['valuation_symbol'])\r\n# 3. 根据PCF_ttm因子选出的股票列表\r\ndef stocks_PCF_ttm(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    PCF_ttm = get_fundamentals(query(\r\n            valuation.symbol,\r\n            valuation.pcf_ttm\r\n        ).filter(\r\n            valuation.pcf_ttm > 0\r\n        ).order_by(\r\n            valuation.pb.asc()\r\n        ),date = last_date)\r\n    PCF_ttm_limit = PCF_ttm['valuation_pcf_ttm'].mean()*1.5\r\n    PCF_ttm = PCF_ttm[PCF_ttm['valuation_pcf_ttm']<=PCF_ttm_limit]\r\n    return list(PCF_ttm['valuation_symbol'])\r\n    \r\n# 4. 根据长期负债与运营资金比率条件筛选股票列表\r\ndef stocks_Debt_asset(context, bar_dict):\r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    Debt_asset = get_fundamentals(query(\r\n            debtrepay.symbol,\r\n            debtrepay.equity_ratio\r\n        ).filter(\r\n            debtrepay.equity_ratio<0.8\r\n            ),date = last_date)\r\n    return list(Debt_asset['debtrepay_symbol'])",
        "created": "2019-01-08T09:51:03",
        "progress": 1,
        "stop_run_time": "2019-01-08T09:52:25",
        "frequency": "DAILY",
        "run_env": "py35",
        "style": "NORMAL",
        "status": "SUCCESS",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "modified": "2019-01-08T09:52:25",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T09:51:03",
        "end_date": "2018-12-31",
        "simu_on": false,
        "inner": true,
        "stock_market": "STOCK",
        "strategylib": true
      },
      {
        "name": "本杰明格雷厄姆企业主投资法",
        "code": "'''\n本杰明格雷厄姆企业主投资法\n作者：warrior_f\n\n策略选股:\nA．股票的市盈率大于0，且选取市盈率最低的400只股票 \nB．股票的市净率大于0且小于2.5，且选取市净率最低的400只股票 \nC．企业的流动资产至少是流动负债的1.2 倍 \nD．企业的总借款不超过净流动资产的1.5 倍 \nE．企业净利润大于0 \nF．最近一期现金股利大于0 \nG．净利润增长率从大到小排序，选取前400只股票 \nH. 满足于上述7个条件下的前30只股票\n\n交易方式：\n按月调仓\n\n止损方式:\nA. 当个股价格低于成本价的7%时，卖出该股票 \nB. 当5日内大盘下跌13%时，卖出所有股票\n\n'''\nfrom datetime import timedelta, date\nimport pandas as pd\n\n############################## 以下为主要函数  ################################\n# 初始化函数 ##################################################################\ndef init(context):\n    # set_commission(PerTrade(cost=0.0003, min_trade_cost=5))\n    # set_slippage(PriceRelatedSlippage())\n    context.selected = 400\n    context.n = 30 # 持股数\n    #调仓频率\n    context.trade_date = range(1,13,1)\n    ## 按月调用程序\n    run_monthly(trade,date_rule=-1)\n# 月末调仓函数 #################################################################\ndef trade(context, bar_dict):\n    date = get_datetime()\n    months = get_datetime().month\n    if months in context.trade_date:\n       \n        \n        ##获得购买股票列表\n        PE_list = stocks_PE(context,bar_dict)\n        PB_list = stocks_PB(context,bar_dict)\n        current_ratio_list = stocks_current_ratio(context,bar_dict)\n        Debt_asset_list = stocks_Debt_asset(context,bar_dict)\n        netProfitGrowthrate_list = stocks_netProfitGrowthrate(context,bar_dict)\n        netprofit = stocks_netprofit(context,bar_dict)\n        ## 获得满足每种条件的股票池\n        stock_list = list(set(PE_list)&set(PB_list)&set(current_ratio_list)&set(Debt_asset_list)&set(netProfitGrowthrate_list)&set(netprofit))\n        log.info(len(stock_list))\n        \n        ## 卖出\n        if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()):\n                if stock not in stock_list:\n                    order_target(stock, 0)\n        ## 买入\n        if len(stock_list) > 0:\n            for stock in stock_list:\n                if stock not in list(context.portfolio.stock_account.positions.keys()):\n                    if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                        number = context.n  - len(list(context.portfolio.stock_account.positions.keys()))\n                        order_value(stock,context.portfolio.available_cash/number)\n                    else: \n                        order_value(stock,context.portfolio.available_cash)\n                           \n    else:\n        pass\n    \n# 每日检查止损条件 #############################################################\ndef handle_bar(context, bar_dict):\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.07\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = - 0.13\n        T = history('000001.SH',['quote_rate'],5,'1d').values.sum()\n        if T < num*100:\n            log.info('上证指数连续三天下跌{}已清仓'.format(T))\n            for stock in holdstock:\n                order_target(stock,0)\n\n################## 以下为功能函数, 在主要函数中调用 ##########################\n\n# 1. 根据市盈率筛选股票列表\ndef stocks_PE(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    PE = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pe\n        ).filter(\n            valuation.pe > 0,\n        ).order_by(\n            valuation.pe.asc()\n        ).limit(\n            context.selected\n        ),date = current_date)\n\n    return list(PE['valuation_symbol'])\n# 2. 根据市净率筛选股票列表\ndef stocks_PB(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    PB = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pb\n        ).filter(\n            valuation.pb > 0,\n            valuation.pb < 2.5\n        ).order_by(\n            valuation.pb.asc()\n        ).limit(\n            context.selected\n        ),date = current_date)\n \n    \n    return list(PB['valuation_symbol'])\n# 3. 根据流动比率筛选股票列表\ndef stocks_current_ratio(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    Current_ratio = get_fundamentals(query(\n            debtrepay.symbol,\n            debtrepay.current_ratio\n        ).filter(\n            debtrepay.current_ratio>1.2\n        ).order_by(\n            debtrepay.current_ratio.desc()\n        ),date = current_date)\n        \n    return list(Current_ratio['debtrepay_symbol'])\n\n# 4. 根据长期与运营资金比率条件筛选股票列表\ndef stocks_Debt_asset(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    Debt_asset = get_fundamentals(query(\n            debtrepay.symbol,\n            debtrepay.long_term_debt_to_opt_capital_ratio\n        ).filter(\n            debtrepay.long_term_debt_to_opt_capital_ratio<1.5\n            ),date = current_date)\n    return list(Debt_asset['debtrepay_symbol'])\n    \n# 5. 根据净利润增长率条件筛选股票列表    \ndef stocks_netProfitGrowthrate(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    net_profit_growth_ratio = get_fundamentals(query(\n            growth.symbol,\n            growth.net_profit_growth_ratio \n        ).filter(\n            growth.net_profit_growth_ratio>0\n        ).order_by(\n            growth.net_profit_growth_ratio.desc()\n        \n        ),date = current_date)\n    return list(net_profit_growth_ratio['growth_symbol'])\n    \n# 6. 根据净利润条件筛选股票列表    \ndef stocks_netprofit(context,bar_dict):\n    current_date = get_last_datetime().strftime('%Y%m%d')\n    netprofit = get_fundamentals(query(\n            income.symbol,\n            income.net_profit \n        ).filter(\n            income.net_profit > 0\n            ),date = current_date)\n    \n    return list(netprofit['income_symbol'])\n",
        "created": "2019-01-08T10:28:55",
        "progress": 1,
        "stop_run_time": "2019-01-08T10:31:03",
        "frequency": "DAILY",
        "id": "5c340ae775019f000c97f7c1",
        "run_env": "py35",
        "style": "NORMAL",
        "status": "SUCCESS",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "modified": "2019-01-08T10:31:03",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T10:28:55",
        "end_date": "2018-12-31",
        "simu_on": false,
        "inner": true,
        "stock_market": "STOCK",
        "strategylib": true
      },
      {
        "name": "史蒂夫·路佛价值选股法则",
        "id": "5c340bb0e052f2000ae08f1c",
        "begin_date": "2014-01-01",
        "progress": 1,
        "capital_base": 1000000,
        "end_date": "2018-12-31",
        "algo_gen_method": "MANUAL",
        "style": "NORMAL",
        "start_run_time": "2019-01-08T10:32:16",
        "created": "2019-01-08T10:32:16",
        "frequency": "DAILY",
        "status": "SUCCESS",
        "inner": true,
        "stock_market": "STOCK",
        "modified": "2019-01-08T10:33:47",
        "simu_on": false,
        "run_env": "py35",
        "stop_run_time": "2019-01-08T10:33:47",
        "code": "'''\n史蒂夫·路佛价值选股法则\n作者：warrior_f\n\n策略选股:\n\nA 市净率大于0且低于全市场平均值，股票按市净率从小到大排列\nB.市盈率大于0且低于全市场平均值，股票按市盈率从小到大排列\nC 流动资产至少是总市值的30%\nD 股价现金流量比大于0且低于全市场平均值，股票按股价现金流量从小到大排列\nE 长期借款占总资本比率低于50%\nF 流动比率高于全市场平均值,股票按流动比率从大到小排列\nG 满足上述条件下股票池中前30只股票\n\n交易方式：\n按月调仓\n\n止损方式:\nA. 当个股价格低于成本价的7%时，卖出该股票 \nB. 当5日内大盘下跌13%时，卖出所有股票\n\n'''\nfrom datetime import timedelta, date\nimport pandas as pd\n\n############################## 以下为主要函数  ################################\n# 初始化函数 ##################################################################\ndef init(context):\n    # set_commission(PerTrade(cost=0.0003, min_trade_cost=5))\n    # set_slippage(PriceRelatedSlippage())\n    context.n = 30 # 持股数\n    #调仓频率\n    context.trade_date = range(1,13,1)\n    ## 按月调用程序\n    run_monthly(trade,date_rule=-1)\n# 月末调仓函数 #################################################################\ndef trade(context, bar_dict):\n    date = get_datetime()\n    months = get_datetime().month\n    if months in context.trade_date:\n       \n        \n        ##获得购买股票列表\n        PB_list = stocks_PB(context,bar_dict)\n        log.info(len(PB_list))\n        PE_list = stocks_PE(context,bar_dict)\n        log.info(len(PE_list))\n        curAst_to_cap_list = stocks_curAst_to_cap(context,bar_dict)\n        log.info(len(curAst_to_cap_list))\n        PCF_list = stocks_PCF(context,bar_dict)\n        log.info(len(PCF_list))\n        equity_ratio_list = stocks_equity_ratio(context,bar_dict)\n        log.info(len(equity_ratio_list))\n        current_ratio_list = stocks_current_ratio(context,bar_dict)\n        log.info(len(current_ratio_list))\n        ## 获得满足每种条件的股票池\n        stock_list = list(set(PB_list)&set(PE_list)&set(PCF_list)&set(equity_ratio_list)&set(curAst_to_cap_list)&set(current_ratio_list))\n        log.info(len(stock_list))\n        \n        ## 卖出\n        if len(list(context.portfolio.stock_account.positions.keys()) ) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()) :\n                if stock not in stock_list:\n                    order_target(stock, 0)\n        ## 买入\n        if len(stock_list) > 0:\n            for stock in stock_list:\n                if stock not in list(context.portfolio.stock_account.positions.keys()) :\n                    if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                        number = context.n  - len(list(context.portfolio.stock_account.positions.keys()) )\n                        order_value(stock,context.portfolio.available_cash/number)\n                    else: \n                        order_value(stock,context.portfolio.available_cash)\n                           \n    else:\n        pass\n    \n# 每日检查止损条件 #############################################################\ndef handle_bar(context,bar_dict):\n\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.07\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = - 0.13\n        T = history('000001.SH',['quote_rate'],5,'1d').values.sum()\n        if T < num*100:\n            log.info('上证指数连续三天下跌{}已清仓'.format(T))\n            for stock in holdstock:\n                order_target(stock,0)\n\n################## 以下为功能函数, 在主要函数中调用 ##########################\n\n\n# 1. 根据市净率筛选股票列表\ndef stocks_PB(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PB = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pb\n        ).filter(\n            valuation.pb > 0\n        ).order_by(\n            valuation.pb.asc()\n        ),date = last_date)\n    PB_mean = PB['valuation_pb'].mean()\n    PB = PB[PB['valuation_pb']<PB_mean]\n    return list(PB['valuation_symbol'])\n    \n# 2. 根据市盈率筛选股票列表\ndef stocks_PE(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PE = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pe\n        ).filter(\n            valuation.pe > 0\n        ).order_by(\n            valuation.pe.asc()\n        ),date = last_date)\n    PE_mean = PE['valuation_pe'].mean()\n    PE = PE[PE['valuation_pe']<PE_mean]        \n    return list(PE['valuation_symbol'])\n# 3. 根据流动资产和市值条件来筛选股票列表\ndef stocks_curAst_to_cap(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    curAst_to_cap_list = get_fundamentals(query(\n            balance.symbol,\n            balance.total_current_assets,\n            valuation.market_cap\n        ),date = last_date)\n    curAst_to_cap_list['curAst_to_cap'] = curAst_to_cap_list['balance_total_current_assets']/curAst_to_cap_list['valuation_market_cap']\n    curAst_to_cap_list = curAst_to_cap_list[curAst_to_cap_list['curAst_to_cap']>=0.3]\n    return list(curAst_to_cap_list['balance_symbol'])\n# 4. 根据市现率筛选股票列表\ndef stocks_PCF(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PCF = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pcf\n        ).filter(\n            valuation.pcf > 0\n        ).order_by(\n            valuation.pcf.asc()\n        ),date = last_date)\n\n    PCF_mean = PCF['valuation_pcf'].mean()\n    PCF = PCF[PCF['valuation_pcf']<PCF_mean]    \n    return list(PCF['valuation_symbol'])\n# 5. 根据产权比率条件来筛选股票列表\ndef stocks_equity_ratio(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    equity_ratio = get_fundamentals(query(\n            debtrepay.symbol,\n            debtrepay.equity_ratio\n        ).filter(\n            debtrepay.equity_ratio<0.5\n            ),date = last_date)\n    return list(equity_ratio['debtrepay_symbol'])\n# 6. 根据流动比率筛选股票列表\ndef stocks_current_ratio(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    Current_ratio = get_fundamentals(query(\n            debtrepay.symbol,\n            debtrepay.current_ratio\n        ).order_by(\n            debtrepay.current_ratio.desc()\n        ),date = last_date)\n    Current_ratio_mean = Current_ratio['debtrepay_current_ratio'].mean()\n    Current_ratio = Current_ratio[Current_ratio['debtrepay_current_ratio']>Current_ratio_mean]    \n    return list(Current_ratio['debtrepay_symbol'])\n",
        "strategylib": true
      },
      {
        "name": "三一投资管理公司价值选股策略",
        "id": "5c340d2d5919f2000cf32de2",
        "simu_on": false,
        "frequency": "DAILY",
        "created": "2019-01-08T10:38:37",
        "inner": true,
        "stop_run_time": "2019-01-08T10:42:30",
        "capital_base": 1000000,
        "run_env": "py35",
        "stock_market": "STOCK",
        "start_run_time": "2019-01-08T10:38:37",
        "code": "'''\n三一投资管理公司价值选股策略\n作者：warrior_f\n\n具体策略 \n一、每月作为调仓周期，选取符合以下条件的股票进入投资组合：\n选取本益比最低的前400公司\n股价账面价值比最低的前400公司\n股利收益率最高的前400公司 为了控制每期选出的股票数，我们增加如下条件：\n若选出股票超过30 个，选取前30个进入组合。\n\n二、止损方式\n当个股价格低于成本价的8%时，卖出该股票\n当5日内大盘下跌13%时，卖出所有股票\n\n'''\nfrom datetime import timedelta, date\nimport pandas as pd\n\n############################## 以下为主要函数  ################################\n# 初始化函数 ##################################################################\ndef init(context):\n\n    # set_commission(PerTrade(cost=0.0003, min_trade_cost=5))\n    # set_slippage(PriceRelatedSlippage())\n    \n    context.selected = 400\n    #设置持仓的数量\n    context.n = 30 \n    #月度调仓\n    context.trade_date = range(1,13,1)\n    #交易按月运行\n    run_monthly(trade,date_rule=-1)\n# 月末调仓函数 #################################################################\ndef trade(context, bar_dict):\n    months = get_datetime().month\n    if months in context.trade_date:\n       \n        \n        ##获得购买股票列表\n        PE_list = stocks_PE(context,bar_dict)\n        PB_list = stocks_PB(context,bar_dict)\n        DR_list = stocks_DR(context,bar_dict)\n        DY_list = list(dict(DR_list).keys())\n        stock_list = list(set(PE_list)&set(PB_list)&set(DY_list))\n        log.info(len(stock_list))\n        \n        ## 卖出\n        if len(list(context.portfolio.stock_account.positions.keys()) ) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()) :\n                if stock not in stock_list:\n                    order_target(stock, 0)\n        ## 买入\n        if len(stock_list) > 0:\n            for stock in stock_list:\n                if stock not in list(context.portfolio.stock_account.positions.keys()) :\n                    if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                        number = context.n  - len(list(context.portfolio.stock_account.positions.keys()) )\n                        order_value(stock,context.portfolio.available_cash/number)\n                    else: \n                        order_value(stock,context.portfolio.available_cash)\n                           \n    \n# 每日检查止损条件 #############################################################\ndef handle_bar(context,bar_dict):\n\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.07\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = - 0.13\n        T = history('000001.SH',['quote_rate'],5,'1d').values.sum()\n        if T < num*100:\n            log.info('上证指数连续三天下跌{}已清仓'.format(T))\n            for stock in holdstock:\n                order_target(stock,0)\n\n\n################## 以下为功能函数, 在主要函数中调用 ##########################\n# 1.根据市盈率筛选股票列表\ndef stocks_PE(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PE = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pe\n        ).filter(\n            valuation.pe > 0,\n        ).order_by(\n            valuation.pe.asc()\n        ).limit(\n            context.selected\n        ),date = last_date)\n\n    return list(PE['valuation_symbol'])\n    \n# 2.根据市净率筛选股票列表\ndef stocks_PB(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PB = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pb\n        ).filter(\n            valuation.pb > 0,\n        ).order_by(\n            valuation.pb.asc()\n        ).limit(\n            context.selected\n        ),date = last_date)\n \n    \n    return list(PB['valuation_symbol'])\n    \n# 3.根据股息率（每股收益/每股市价代替）来筛选股票列表\ndef stocks_DR(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    EPS = get_fundamentals(query(\n        income.symbol,\n        income.basic_eps\n    ),date = last_date)\n    stock_List = list(EPS['income_symbol'])\n    close_price = history(stock_List,['close'],1,'1d',True,None)\n    DY_stock = dict(zip(EPS['income_symbol'],EPS['income_basic_eps']))\n    log.info(len(DY_stock)-len(EPS['income_symbol']))\n    for stock in stock_List:\n        try:\n            DY_stock[stock] = DY_stock[stock]/close_price[stock]['close'][0]\n        except:\n            DY_stock[stock] = 0\n    \n\n    DY_stock = sorted(DY_stock.items(),key=lambda t:t[1],reverse=True)\n    return DY_stock[:context.selected]\n\n\n       \n\n\n    \n ",
        "progress": 1,
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "modified": "2019-01-08T10:42:30",
        "status": "SUCCESS",
        "begin_date": "2014-01-01",
        "algo_gen_method": "MANUAL",
        "strategylib": true
      },
      {
        "name": "迈克尔•普莱斯低估价值选股策略",
        "id": "5c340df0a59c54000ae938bc",
        "algo_gen_method": "MANUAL",
        "begin_date": "2014-01-01",
        "stock_market": "STOCK",
        "modified": "2019-01-08T10:43:09",
        "inner": true,
        "created": "2019-01-08T10:41:52",
        "stop_run_time": "2019-01-08T10:43:09",
        "style": "NORMAL",
        "progress": 1,
        "status": "SUCCESS",
        "frequency": "DAILY",
        "capital_base": 1000000,
        "run_env": "py35",
        "code": "'''\n迈克尔•普莱斯低估价值选股策略\n作者：warrior_f\n\n策略选股:\nA 股价与每股净值比小于2，且选取市净率最低的400只股票 \nB 董监事持股比例大于市场平均值(缺失该数据)\nC 负债比例低于市场平均值\nD. 满足于上述条件下的前30只股票\n\n交易方式：\n按月调仓\n\n止损方式:\nA. 当个股价格低于成本价的7%时，卖出该股票 \nB. 当5日内大盘下跌13%时，卖出所有股票\n\n'''\nfrom datetime import timedelta, date\nimport pandas as pd\n\n############################## 以下为主要函数  ################################\n# 初始化函数 ##################################################################\ndef init(context):\n    # set_commission(PerTrade(cost=0.0003, min_trade_cost=5))\n    # set_slippage(PriceRelatedSlippage())\n    context.selected = 400\n    context.n = 30 # 持股数\n    #调仓频率\n    context.trade_date = range(1,13,1)\n    ## 按月调用程序\n    run_monthly(trade,date_rule=-1)\n# 月末调仓函数 #################################################################\ndef trade(context, bar_dict):\n    date = get_datetime()\n    months = get_datetime().month\n    if months in context.trade_date:\n       \n        \n        ##获得购买股票列表\n        PB_list = stocks_PB(context,bar_dict)\n        Equity_ratio_list = stocks_equity_ratio(context,bar_dict)\n        ## 获得满足每种条件的股票池\n        stock_list = list(set(PB_list)&set(Equity_ratio_list))\n        log.info(len(stock_list))\n        \n        ## 卖出\n        if len(list(context.portfolio.stock_account.positions.keys()) ) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()) :\n                if stock not in stock_list:\n                    order_target(stock, 0)\n        ## 买入\n        if len(stock_list) > 0:\n            for stock in stock_list:\n                if stock not in list(context.portfolio.stock_account.positions.keys()) :\n                    if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                        number = context.n  - len(list(context.portfolio.stock_account.positions.keys()) )\n                        order_value(stock,context.portfolio.available_cash/number)\n                    else: \n                        order_value(stock,context.portfolio.available_cash)\n\n# 每日检查止损条件 #############################################################\ndef handle_bar(context,bar_dict):\n  #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.07\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = - 0.13\n        T = history('000001.SH',['quote_rate'],5,'1d').values.sum()\n        if T < num*100:\n            log.info('上证指数连续三天下跌{}已清仓'.format(T))\n            for stock in holdstock:\n                order_target(stock,0)\n\n################## 以下为功能函数, 在主要函数中调用 ##########################\n\n\n# 1. 根据市净率筛选股票列表\ndef stocks_PB(context, bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    PB = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pb\n        ).filter(\n            valuation.pb > 0,\n            valuation.pb < 2\n        ).order_by(\n            valuation.pb.asc()\n        ).limit(\n            context.selected\n        ),date = last_date)\n \n    \n    return list(PB['valuation_symbol'])\n\n# 5. 根据负债比例条件来筛选股票列表\ndef stocks_equity_ratio(context, bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    equity_ratio = get_fundamentals(query(\n            debtrepay.symbol,\n            debtrepay.equity_ratio\n        ),date = last_date)\n    equity_ratio_mean = equity_ratio['debtrepay_equity_ratio'].mean()\n    equity_ratio = equity_ratio[equity_ratio['debtrepay_equity_ratio']<equity_ratio_mean]    \n    return list(equity_ratio['debtrepay_symbol'])",
        "end_date": "2018-12-31",
        "start_run_time": "2019-01-08T10:41:52",
        "simu_on": false,
        "strategylib": true,
        "libresearchinfo": {
          "id": "5c355d5baba4ff000c238a87",
          "clone_count": 0,
          "path": "迈克尔•普莱斯低估价值.ipynb",
          "user_id": "385045923",
          "share_filename": "04e17b70b333efc322b5d88ba9f7a2f1.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/385045923/04e17b70b333efc322b5d88ba9f7a2f1.html"
        }
      }
    ]
  },
  {
    "folder_id": "9",
    "name": "入门教材策略",
    "children": [
      {
        "name": "单因子策略(一)",
        "id": "5c3442ecac17c6000a02a951",
        "created": "2019-01-08T14:27:56",
        "code": "#====================================================================================================\n#在编写策略时，我们首先需要大致确定一下我们编写过程需要用到的几个Python包，比如numpy.pandas.datetime，您\n#需要根据您的需求，在策略的最上方进行导包操作。\nfrom datetime import timedelta, date\n#导入datetime相关包\nimport pandas as pd\n#导入pandas包，用于数据分析。\n#====================================================================================================\n#====================================================================================================\n#首先我们需要一个策略初始化函数，其功能相当于开户。\ndef init(context):\n#def是Python语言创建函数的标志，initialize是函数名称，这里是初始化函数，（context）是账户信息对象，也就是\n#该初始化函数中，只有初始一些账户信息。并且该函数只运行一次，相当于开户只需要一次就可以了。\n    context.n = 15 \n    #设置n=15，并将其放到账户信息中，主要为了控制持股数量，控制到15个及以内。\n    run_monthly(trade,date_rule=-1)\n    #按月运行函数run_monthly（a,b），其中里面有两个参数，a是运行对象，这里是trade函数（详见34行代码），\n    #b是运行时间，这里是每个月倒数第一个交易日。\n#====================================================================================================\n#====================================================================================================\n#其次我们需要构建一个交易系统，使得整个策略能运行起来！\ndef trade(context, bar_dict):\n#我们创建一个取名为trade的函数，用于交易，其中设置context参数，我们就可以到别的函数中的context对象中的信息\n#用到这里来，另外我们还有bar_dict参数，用于计算数据。\n    pb_list = stocks_pb(context,bar_dict)\n    #我们将stocks_pb(context,bar_dict)函数的选股结果导入pb_list对象\n    stock_list = list(set(pb_list))\n    #我们需要将pb_list对象的格式进行转化，使得运行不出错，直接用list(set(x))即可。其中set()是创建集合\n    #这里是创建股票集合，list()用来创建列表，这里是创建股票列表。\n    if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n    #if 判断函数，len()是取长度数值，context.positions是账户持仓信息，len(context.positions)也就是\n    #当前持仓股票的数量，如果大于0，则进行下一步。\n        for stock in list(context.portfolio.stock_account.positions.keys()):\n        #for x in y 是循环函数，从y中逐一取出来设为x，这里的y是持仓个股列表。x是stock，将个股取出，\n        #stock中存放取出的个股，执行下一步，如果一个个股执行完毕，执行下一个个股，直到账户中所有持仓\n        #个股全部被执行后，跳出循环。\n            if stock not in stock_list:\n            #if判断函数，判断选股股票是否在选股函数列表，不在则运行下一步\n                order_target(stock, 0)\n                #order_target下单函数，stock是买卖的股，0是目前持仓，也就是清仓。\n    if len(stock_list) > 0:\n    #if 判断函数，判断选股列表中股票数量是否大于0\n        for stock in stock_list:\n        #for x in y循环函数，从股票列表中逐一取出个股\n            if stock not in list(context.portfolio.stock_account.positions.keys()):\n            #if判断函数，用于判断个股是否在个股持仓列表中。\n                if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                #if 判断函数，用于判断持仓个股数，是否小于我们初始化设置的条件15个。\n                    number = context.n  - len(list(context.portfolio.stock_account.positions.keys()))\n                    #如果不超出，那么计算，我们还能买的个股数量\n                    order_value(stock,context.portfolio.stock_account.available_cash/number)\n                    #下单函数，执行买入，买入的金额为可用现金/可买个股数\n                else: \n                    order_value(stock,context.portfolio.stock_account.available_cash)\n                #else是if函数的衍生，如果个股数量等于或超过最大持仓，那么我们将剩下的资金全部买入\n\n#====================================================================================================\n#我们需要创建一个函数，其作用是选择我们股票，因子是pb市净率，来让我们的交易系统有股票可以买卖\ndef stocks_pb(context,bar_dict):\n#我们创建一个取名为stocks_pb的函数，用于选股，其中设置context参数，我们就可以到别的函数中的context对象\n#中的信息用到这里来，另外我们还有bar_dict参数，用于计算数据。\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    #get_last_datetime()函数用来获取回测的前一天的日期，后面的strftime('%Y%m%d')是用来转化成年月日的格式。\n    pb = get_fundamentals(query(valuation.symbol,valuation.pb\n                        ).filter(valuation.pb > 0,\n                        ).order_by(valuation.pb.asc()\n                        ),date = last_date)\n    #get_fundamentals是获取财务数据的函数，query(x)是获取对象，这里是股票和pb，filter(y)是用来筛选条件，这\n#里是pb>0，order_by(z)用来排序，将选择后的个股排序，这里是pb从小到大，date是日期，这里是回测前一日。\n#其中sec()是从小到大排序。\n    return list(pb['valuation_symbol'][:15])\n    #return用来输出函数的执行结果。这里是我们选择出来的股票列表的前15只个股。",
        "progress": 1,
        "stop_run_time": "2019-01-08T14:28:13",
        "frequency": "DAILY",
        "run_env": "py35",
        "style": "NORMAL",
        "status": "SUCCESS",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "modified": "2019-01-08T14:28:13",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T14:27:56",
        "end_date": "2018-12-31",
        "simu_on": false,
        "inner": true,
        "stock_market": "STOCK",
        "strategylib": true,
        "libresearchinfo": {
          "share_filename": "f4d636f5ca2fbdf70b2f42bdb2c0fa4d.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/f4d636f5ca2fbdf70b2f42bdb2c0fa4d.html",
          "path": "策略描述.ipynb",
          "user_id": "405282146",
          "id": "59b11db8e0e99b000a1346d7",
          "clone_count": 0
        }
      },
      {
        "name": "多因子策略(二)",
        "id": "5c344396ac17c6000a02a955",
        "start_run_time": "2019-01-08T14:30:46",
        "begin_date": "2014-01-01",
        "run_env": "py35",
        "capital_base": 1000000,
        "simu_on": false,
        "created": "2019-01-08T14:30:46",
        "inner": true,
        "progress": 1,
        "algo_gen_method": "MANUAL",
        "frequency": "DAILY",
        "end_date": "2018-12-31",
        "code": "#========================================================================================\nfrom datetime import timedelta, date\nimport pandas as pd\n#导包操作，我们需要分析时间和数据的两个工具pandas、datetime\n#========================================================================================\n#========================================================================================\n#初始化函数，我们设置最大持股15个，设置交易频率为1-12月，设置trade函数每个月月末运行一次。\ndef init(context):\n    context.n = 15 \n    run_monthly(trade,date_rule=-1)\n#========================================================================================\n#========================================================================================\n#设置交易函数，首先判断时间月份是够满足，随后获取选股函数的结果，将不符合的卖出后符合的买入。\ndef trade(context, bar_dict):\n    pe_ttm_list = stocks_pe_ttm(context,bar_dict)\n    netProfitGrowthrate_list=stocks_netProfitGrowthrate(context,bar_dict)\n    ps_ttm_list=stocks_ps_ttm(context,bar_dict)\n    stock_list = list(set(pe_ttm_list)&set(ps_ttm_list)&set(netProfitGrowthrate_list))\n    #这条代码的&是且的意思，也就是三个set()全部满足的股票构成一个列表。\n    if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n        for stock in list(context.portfolio.stock_account.positions.keys()):\n            if stock not in stock_list:\n                order_target(stock, 0)\n    if len(stock_list) > 0:\n        for stock in stock_list:\n            if stock not in list(context.portfolio.stock_account.positions.keys()):\n                if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                    number = context.n  - len(list(context.portfolio.stock_account.positions.keys()))\n                    order_value(stock,context.portfolio.stock_account.available_cash/number)\n                else: \n                    order_value(stock,context.portfolio.stock_account.available_cash)\n#========================================================================================\n#========================================================================================\n#以下三个是自定义函数区，第一个是根据pe_ttm选股，第二个是净利润增长率，第三个是市销率。\n#三个选股函数性质一致，主要是靠62行代码将其整合，只有会整合，你可以设置很多选股函数，然后自由组合。\ndef stocks_pe_ttm(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    pe_ttm = get_fundamentals(query(\n            valuation.symbol,\n            valuation.pe_ttm\n        ).filter(\n            valuation.pe_ttm > 0,\n        ).order_by(\n            valuation.pe_ttm.asc()\n        ),date = last_date)\n    #get_fundamentals是获取财务数据函数，query是对象，filter是筛选条件，order_by是排序，其中asc()是正序，\n    #desc()是逆序\n    n = len(pe_ttm)\n    #n是获取选股结果的数量\n    return list(pe_ttm['valuation_symbol'][:int(n*0.2)])\n    #int()是转成成数字格式\n    #return是输出函数结果，这里是前20%的个股\ndef stocks_netProfitGrowthrate(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    net_profit_growth_ratio = get_fundamentals(query(\n                                  growth.symbol,\n                                  growth.net_profit_growth_ratio \n                                  ).filter(growth.net_profit_growth_ratio>0\n                                  ).order_by(growth.net_profit_growth_ratio.desc()\n                                  ),date = last_date)\n    n = len(net_profit_growth_ratio)\n    return list(net_profit_growth_ratio['growth_symbol'][:int(n*0.2)])\ndef stocks_ps_ttm(context,bar_dict):\n    last_date = get_last_datetime().strftime('%Y%m%d')\n    ps_ttm = get_fundamentals(query(\n            valuation.symbol,\n            valuation.ps_ttm\n        ).filter(\n            valuation.ps_ttm>0\n        ).order_by(\n            valuation.ps_ttm.asc()      \n        ),date = last_date)\n    n=len(ps_ttm)\n    return list(ps_ttm['valuation_symbol'][:int(n*0.2)])\n#========================================================================================\n#========================================================================================",
        "stock_market": "STOCK",
        "status": "SUCCESS",
        "style": "NORMAL",
        "modified": "2019-01-08T14:31:26",
        "stop_run_time": "2019-01-08T14:31:26",
        "strategylib": true,
        "libresearchinfo": {
          "id": "59b120a4bb8d9c000cca1a16",
          "share_filename": "338e4769e7b8b16ab1c2446ea03ae989.ipynb",
          "user_id": "405282146",
          "path": "多因子.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/338e4769e7b8b16ab1c2446ea03ae989.html",
          "clone_count": 0
        }
      },
      {
        "name": "动量策略(三)",
        "id": "5c344d045919f2000ac3192b",
        "stock_market": "STOCK",
        "stop_run_time": "2019-01-08T15:14:33",
        "progress": 1,
        "begin_date": "2014-01-01",
        "algo_gen_method": "MANUAL",
        "frequency": "DAILY",
        "style": "NORMAL",
        "code": "#==================================================================================================\n#导包操作\nfrom datetime import timedelta, date\nimport pandas as pd\n#==================================================================================================\n#==================================================================================================\n#初始化函数，设置初始条件\ndef init(context):\n    context.n = 50\n    #设置最大持股\n    run_monthly(trade,date_rule=2)\n    #设置trade函数能每个月月初第二个交易日运行\n    get_iwencai('未停牌,上市时间超过2年')\n    #使用问财进行选股，每日执行一次，储存在context.iwencai_securities对象中\n#==================================================================================================\n#==================================================================================================\n#设置止损止盈，handle_bar是每日（分钟/tick）运行\ndef handle_bar(context,bar_dict):\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.1\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n#==================================================================================================\n#==================================================================================================\n#选股函数，这里用字典选股\ndef stocks_zf(context,bar_dict):\n    df = {'security': [], '30zf': []}\n    #创建字典，格式如上。'security'是键，[]是值。\n    stocks=context.iwencai_securities\n    #将问财选股结果导到stocks\n    for symbol in stocks:\n        df['security'].append(symbol)\n        #将依次选出的个股添加到字典的键'security'的值中，这里append是添加操作。\n    for i in range(len(df['security'])):\n        quote = history(df['security'][i], ['quote_rate'], 30, '1d', True, fq='pre')\n        #获取过去30日涨跌幅数据\n        AMP30 = quote.values[:].sum()\n        #将这些数据求和，直接是.sum()\n        df['30zf'].append(AMP30)\n        #将计算出的值添加到键中\n    df = pd.DataFrame(df).sort_values(by ='30zf', ascending=False)\n    #pd.bar_dictFrame(df)将字典转化成bar_dictFrame格式，.sort_values是排序，by是以XX为标准排序，ascending=False\n    #是从大到小排序。\n    context.sample = df['security'][:50]\n    #截取排序后的DF格式的前50个股票，并输出\n    return context.sample\n#==================================================================================================\n#==================================================================================================\ndef trade(context, bar_dict):\n    zf_list = stocks_zf(context,bar_dict)\n    #将选股函数的结果导到zf_list中，用于交易函数运行。\n    stock_list = list(set(zf_list))\n    if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n        for stock in list(list(context.portfolio.stock_account.positions.keys())):\n            if stock not in stock_list:\n                order_target(stock, 0)\n    if len(stock_list) > 0:\n        for stock in stock_list:\n            if stock not in list(list(context.portfolio.stock_account.positions.keys())):\n                if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                    number = context.n  - len(list(context.portfolio.stock_account.positions.keys()))\n                    order_value(stock,context.portfolio.stock_account.available_cash/number)\n                else: \n                    order_value(stock,context.portfolio.stock_account.available_cash)\n\n",
        "inner": true,
        "capital_base": 1000000,
        "start_run_time": "2019-01-08T15:11:00",
        "run_env": "py35",
        "end_date": "2018-12-31",
        "simu_on": false,
        "status": "SUCCESS",
        "created": "2019-01-08T15:11:00",
        "modified": "2019-01-08T15:14:33",
        "strategylib": true,
        "libresearchinfo": {
          "id": "59b12354e0e99b000a1346d8",
          "share_filename": "b3d1289d89a32e1c76ba9e4293f4be30.ipynb",
          "clone_count": 0,
          "path": "动量.ipynb",
          "user_id": "405282146",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/b3d1289d89a32e1c76ba9e4293f4be30.html"
        }
      },
      {
        "name": "反转效应(四)",
        "simu_on": false,
        "frequency": "DAILY",
        "created": "2019-01-08T15:21:30",
        "inner": true,
        "stop_run_time": "2019-01-08T15:22:40",
        "capital_base": 1000000,
        "run_env": "py35",
        "stock_market": "STOCK",
        "start_run_time": "2019-01-08T15:21:30",
        "code": "#===================================================================================================\n#导包操作\nfrom datetime import timedelta, date\nimport pandas as pd\n#===================================================================================================\n#===================================================================================================\n#初始化函数，设置初始条件\ndef init(context):\n    context.n = 25 \n    run_monthly(trade,date_rule=-1)\n    get_iwencai('沪深300,未停牌,上市时间超过2年')\n#===================================================================================================\n#===================================================================================================\n#止损止盈函数\ndef handle_bar(context,bar_dict):\n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.1\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n#===================================================================================================\n#===================================================================================================\n#选股函数\ndef stocks_fz1(context,bar_dict):\n    df = {'security': [], '30zf': []}\n    stocks=context.iwencai_securities\n    for symbol in stocks:\n        df['security'].append(symbol)\n    for i in range(len(df['security'])):\n        quote = history(df['security'][i], ['quote_rate'], 30, '1d', True, fq='pre')\n        AMP30 = quote.values[:].sum()\n        df['30zf'].append(AMP30)\n    df = pd.DataFrame(df).sort_values(by ='30zf', ascending=True)\n    context.fz = df['security'][:50]\n    return context.fz\ndef stocks_fz2(context,bar_dict):\n    df = {'security': [], '30cje': []}\n    security=stocks_fz1(context,bar_dict)\n    #该策略选股函数中，我们通过一个函数的结果，导到第二个函数中去运行，可以达到多步骤选股\n    stock=security\n    for symbol in stock:\n        df['security'].append(symbol)\n    for i in range(len(df['security'])):\n        quote = history(df['security'][i], ['turnover'], 30, '1d', True, fq='pre')\n        AMP30 = quote.values[:].sum()\n        df['30cje'].append(AMP30)\n    df = pd.DataFrame(df).sort_values(by ='30cje', ascending=True)\n    context.cje = df['security'][:25]\n    return context.cje\n#===================================================================================================\n#===================================================================================================\n#交易函数\ndef trade(context, bar_dict):\n    fz_list = stocks_fz2(context,bar_dict)\n    stock_list = list(set(fz_list))\n    if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n        for stock in list(context.portfolio.stock_account.positions.keys()):\n            if stock not in stock_list:\n                order_target(stock, 0)\n    if len(stock_list) > 0:\n        for stock in stock_list:\n            if stock not in list(context.portfolio.stock_account.positions.keys()):\n                if len(list(context.portfolio.stock_account.positions.keys())) < context.n :\n                    number = context.n  - len(list(context.portfolio.stock_account.positions.keys()))\n                    order_value(stock,context.portfolio.stock_account.available_cash/number)\n                else: \n                    order_value(stock,context.portfolio.stock_account.available_cash)\n",
        "progress": 1,
        "id": "5c344f7a4b82ee000ca252ac",
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "modified": "2019-01-08T15:22:40",
        "status": "SUCCESS",
        "begin_date": "2014-01-01",
        "algo_gen_method": "MANUAL",
        "strategylib": true,
        "libresearchinfo": {
          "path": "反转.ipynb",
          "user_id": "405282146",
          "share_filename": "3ad5cca0f0afa39d61221ffd5885117e.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/3ad5cca0f0afa39d61221ffd5885117e.html",
          "clone_count": 0,
          "id": "59b1274ee0e99b000c78fe73"
        }
      },
      {
        "name": "双板块轮动(五)",
        "id": "5c3450753eefe6000c3b829a",
        "code": "#==================================================================================================== \n#==================================================================================================== \n#初始化函数，设置初始条件\ndef init(context):   \n    run_weekly(trade,date_rule=1)\n#==================================================================================================== \n#==================================================================================================== \n#判断两个板块的牛熊值\ndef jinrong(context,bar_dict):  \n    price = history('399240.SZ', ['close'], 25, '1d')\n    p20=price['close'].iloc[-20]\n    p1=price['close'].iloc[-1]\n    n=(p1-p20)/p20\n    return n\n    #输出金融板块的强弱值\ndef xiaofei(context,bar_dict):\n    price = history('000036.SH', ['close'], 25, '1d')\n    p20=price['close'].iloc[-20]\n    p1=price['close'].iloc[-1]\n    m=(p1-p20)/p20\n    return m\n    #输出消费板块的强弱值\n#==================================================================================================== \n#==================================================================================================== \ndef trade(context,bar_dict):\n    n=jinrong(context,bar_dict)\n    m=xiaofei(context,bar_dict)\n    #如果两者都弱，则判断是否有持仓，有持仓就卖出\n    if n <= 0 and m <= 0:\n        if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()):\n                order_target(stock, 0)\n    #第二情况，如果其中一者是强的，那么持有弱的卖出弱的，未持有强的买入强的，\n    elif n > m:\n        if '159928.OF' in list(context.portfolio.stock_account.positions.keys()):\n            order_target('159928.OF', 0)\n        if len(list(context.portfolio.stock_account.positions.keys())) < 1:\n            order_target_value('510230.OF', context.portfolio.stock_account.available_cash)\n            #context.cash是账户可用资金，实时变动，保持最新\n    elif n < m:\n        if '510230.OF' in list(context.portfolio.stock_account.positions.keys()):\n            order_target('510230.OF', 0)\n        if len(list(context.portfolio.stock_account.positions.keys())) < 1:\n            order_target_value('159928.OF', context.portfolio.stock_account.available_cash)\n#==================================================================================================== \n#====================================================================================================",
        "created": "2019-01-08T15:25:41",
        "stop_run_time": "2019-01-08T15:25:44",
        "frequency": "DAILY",
        "progress": 1,
        "run_env": "py35",
        "modified": "2019-01-08T15:25:44",
        "inner": true,
        "algo_gen_method": "MANUAL",
        "capital_base": 100000,
        "style": "NORMAL",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T15:25:41",
        "end_date": "2018-12-31",
        "simu_on": false,
        "status": "SUCCESS",
        "stock_market": "STOCK",
        "strategylib": true,
        "libresearchinfo": {
          "share_filename": "a4fa01756215fcd94956588aaa6bc94f.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/a4fa01756215fcd94956588aaa6bc94f.html",
          "user_id": "405282146",
          "clone_count": 0,
          "path": "双板块.ipynb",
          "id": "59b1286ddf8aed000aadc42f"
        }
      },
      {
        "name": "多板块轮动(六)",
        "status": "SUCCESS",
        "id": "5c3451009366c2000b33b87e",
        "frequency": "DAILY",
        "capital_base": 100000,
        "code": "#=====================================================================================================\n#=====================================================================================================\n#导包操作\nimport pandas as pd\n#=====================================================================================================\n#=====================================================================================================\n#初始化函数，用于初始条件，其中爱吃醋 context.security中确定策略判断的几大板块\ndef init(context):   \n    run_monthly(trade,date_rule=3)\n    context.security=['150019.SZ','159901.OF','510050.OF',\n                      '159915.OF','510300.OF',\n                      '510500.OF','510180.OF',\n                      '159902.OF','159905.OF']\n                      #注意：格式可以一行，也可以多行，不影响代码运行，4行还只是context.security里的。\n#=====================================================================================================\n#=====================================================================================================\n#板块强弱衡量函数\ndef bankuai(context,bar_dict):  \n    df={'security':[],'qd':[]}\n    stocks=context.security\n    for i in stocks:\n        df['security'].append(i)\n        price = history(i, ['close'], 25, '1d')\n        p20=price['close'].iloc[-20]\n        p1=price['close'].iloc[-1]\n        m=(p1-p20)/p20\n        df['qd'].append(m)\n    df = pd.DataFrame(df).sort_values(by ='qd', ascending=False)\n    x=df['qd'].iloc[0]\n    y=['123']\n    if x >0 :\n        return df['security'].iloc[0]\n    else:\n        return y\n    #直接输出最强的板块，如果所有板块都是负数，那么输出固定值y=['123']\n#=====================================================================================================\n#=====================================================================================================\n#交易函数\ndef trade(context,bar_dict):\n    n=bankuai(context,bar_dict)\n    d=len(n)\n    #首先判断所有板块是否变弱，变弱则清仓\n    if d==1:\n        if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()):\n                order_target(stock, 0)\n    #其次判断最强板块是否是我们持仓的板块，不是则先卖持仓，后买最强板块。\n    else:\n        if n not in list(list(context.portfolio.stock_account.positions.keys())):\n            for stock in list(context.portfolio.stock_account.positions.keys()):\n                order_target(stock, 0)\n            if len(list(context.portfolio.stock_account.positions.keys())) < 1:\n                order_target_value(n, context.portfolio.stock_account.available_cash)\n#=====================================================================================================\n#=====================================================================================================\n#设置止损止盈\ndef handle_bar(context,bar_dict):\n    n=bankuai(context,bar_dict)\n    d=len(n)\n    #判断函数，用于判断板块，如果所有板块都弱了,那么n是1，执行清仓。\n    if d==1:\n        if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n            for stock in list(list(context.portfolio.stock_account.positions.keys())):\n                order_target(stock, 0)",
        "stock_market": "STOCK",
        "modified": "2019-01-08T15:28:17",
        "start_run_time": "2019-01-08T15:28:00",
        "begin_date": "2014-01-01",
        "simu_on": false,
        "stop_run_time": "2019-01-08T15:28:17",
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "progress": 1,
        "inner": true,
        "created": "2019-01-08T15:28:00",
        "run_env": "py35",
        "algo_gen_method": "MANUAL",
        "strategylib": true,
        "libresearchinfo": {
          "share_filename": "e9d482a905c6112a1668ab1535433ad9.ipynb",
          "id": "59b12983bb8d9c000cca1a26",
          "path": "多板块.ipynb",
          "user_id": "405282146",
          "uri": "http://mindgo.10jqka.com.cn/research/users/405282146/e9d482a905c6112a1668ab1535433ad9.html",
          "clone_count": 0
        }
      }
    ]
  },
  {
    "folder_id": "2",
    "name": "技术指标",
    "children": [
      {
        "name": "MACD交易策略",
        "inner": true,
        "created": "2019-01-08T10:51:06",
        "progress": 1,
        "algo_gen_method": "MANUAL",
        "end_date": "2018-12-31",
        "capital_base": 1000000,
        "stop_run_time": "2019-01-08T10:51:10",
        "run_env": "py35",
        "id": "5c34101a75019f000bf41475",
        "benchmark": "000300.SH",
        "begin_date": "2014-01-01",
        "stock_market": "STOCK",
        "style": "NORMAL",
        "status": "SUCCESS",
        "frequency": "DAILY",
        "simu_on": false,
        "code": "'''\r\nMACD技术指标交易策略：\r\nmacd金叉全仓买入并持有，macd死叉卖出并空仓。\r\n\r\n策略使用步骤：\r\n第一步：左侧策略代码编辑面板,代码第16-21行分别输入股票代码、指标参数、基准指数.\r\n第二步：右上角选择回测日期、账户初始资金、回测频率.ps:本策略适合每日频率运行.\r\n第三步：点击左上角“编译运行”白色按钮,进行快速回测,右边查看策略收益走势及运行日志.\r\n第四步：点击右上角“进行回测”蓝色按钮,执行回测并进入回测详情页面,查看策略交易明\r\n        细、历史持仓、策略风险指标等情况.\r\n第五步：在回测详情页面,点击右上角“开启仿真交易”蓝色按钮,策略即可在实时行情中运行,\r\n        打开交易信号提醒,在同花顺APP应用上实时收到策略交易信号.\r\n'''\r\nimport talib\r\ndef init(context):   \r\n    g.security = '600519.SH' #输入股票代码\r\n    #设置MACD模型参数\r\n    g.Short = 12 #短周期平滑均线参数\r\n    g.Long = 26 #长周期平滑均线参数\r\n    g.M = 9 #DIFF的平滑均线参数\r\n    set_benchmark('000300.SH') #设置基准指数，默认为沪深300\r\n    \r\ndef handle_bar(context,bar_dict): \r\n    macd = get_macd(g.security)\r\n    if macd[-1]>0 and macd[-2]<0 and len(list(context.portfolio.stock_account.positions.keys())) == 0:\r\n        order_value(g.security,context.portfolio.available_cash)    \r\n        log.info(\"买入 %s\" % (g.security))    \r\n    if macd[-2]>0 and macd[-1]<0 and len(list(context.portfolio.stock_account.positions.keys())) > 0:    \r\n        order_target(g.security,0)    \r\n        log.info(\"卖出 %s\" % (g.security))\r\ndef get_macd(stock):\r\n    price = history(stock, ['close'], 500, '1d', True, 'pre', is_panel=1)['close']\r\n    DIFF, DEA, MACD = talib.MACD(price.values,\r\n            fastperiod = g.Short, slowperiod = g.Long, signalperiod = g.M)\r\n    return MACD",
        "modified": "2019-01-08T10:51:10",
        "start_run_time": "2019-01-08T10:51:06",
        "modified_by": "hxquantdclient",
        "strategylib": true
      },
      {
        "name": "SAR交易策略",
        "begin_date": "2014-01-01",
        "code": "# SAR策略\r\n# 策略逻辑: 当股票价格从SAR曲线下方开始向上突破SAR曲线时，为买入信号；\r\n#          当股票价格从SAR曲线上方开始向下突破SAR曲线时，为卖出信号。\r\n\r\n\r\n#初始化账户      \r\ndef init(context):      \r\n    #设置要交易的证券(600519.SH 贵州茅台)      \r\n    context.security = '600519.SH'\r\n    #在handle_bar_dict函数中判断：如果是第一天，初始化前日PSAR参数\r\n    context.first_day = True\r\n    \r\n#设置买卖条件，每个交易频率（日/分钟/tick）调用一次   \r\ndef handle_bar(context,bar_dict): \r\n    #获取证券过去3日的价格数据\r\n    price = history(context.security, ['open','high','low','close'], 3, '1d')\r\n\r\n    #如果是第一天\r\n    if context.first_day:\r\n        #初始化前期PSAR参数\r\n        context.pre_acc = 0.02\r\n        \r\n        #如果前日的收盘价高于前日的开盘价\r\n        if price.at[price.index[-2],'close'] > price.at[price.index[-2],'open']:\r\n            #前日的行情为上涨行情\r\n            context.pre_trend = 'bull'\r\n            #前日的极值应为前日最高价\r\n            context.pre_EP = price.at[price.index[-2],'high']\r\n            #前日的PSAR值应为前日最低价\r\n            context.pre_PSAR = price.at[price.index[-2],'low']\r\n        else:\r\n            #前日的行情为下跌行情\r\n            context.pre_trend = 'bear'\r\n            #前日的极值应为前日最低价\r\n            context.pre_EP = price.at[price.index[-2],'low']\r\n            #前日的PSAR值应为前日最高价\r\n            context.pre_PSAR = price.at[price.index[-2],'high']\r\n        \r\n        log.info(\"PSAR初始化完成\")\r\n        context.first_day = False\r\n\r\n    \r\n    #先计算昨日PSAR的公式值\r\n    #昨日PSAR值 = 前日PSAR - 前日加速因子 * (前日PSAR - 前日极值)\r\n    PSAR = context.pre_PSAR - context.pre_acc*(context.pre_PSAR - context.pre_EP)\r\n    \r\n    #如果前日是下跌行情且昨日最高价高于计算出的PASR值时\r\n    if context.pre_trend == 'bear' and price.at[price.index[-1],'high'] > PSAR: \r\n        #PSAR值应为前日极值\r\n        PSAR = context.pre_EP\r\n    #如果前日是上涨行情且昨日最低价高于计算出的PASR值时\r\n    if context.pre_trend == 'bull' and price.at[price.index[-1],'low'] < PSAR:\r\n        #PSAR值应为前日极值\r\n        PSAR = context.pre_EP\r\n    \r\n    #判断昨日的行情趋势\r\n    #如果昨日PSAR值大于昨日收盘价\r\n    if PSAR > price.at[price.index[-1],'close']: \r\n        #跌势\r\n        trend = 'bear'\r\n    #如果昨日PSAR值小于昨日收盘价\r\n    else:\r\n        #涨势\r\n        trend = 'bull'\r\n    \r\n    #计算昨日的极值\r\n    #如果昨日为下跌趋势，昨日极值为前日极值和昨日最低价中的较小值\r\n    if trend == 'bear': EP = min(context.pre_EP, price.at[price.index[-1],'low'])\r\n    #如果昨日为上涨趋势，昨日极值为前日极值和昨日最高价中的较大值\r\n    if trend == 'bull': EP = max(context.pre_EP, price.at[price.index[-1],'high'])\r\n    \r\n    #计算昨日加速因子\r\n    acc = context.pre_acc\r\n    #如果趋势延续且价格极值改变\r\n    if trend == context.pre_trend and EP!=context.pre_EP: \r\n        #加速因子增加0.02\r\n        acc += 0.02\r\n        #加速因子不能大于0.2\r\n        acc = min(acc, 0.2)\r\n    #如果趋势改变\r\n    if trend != context.pre_trend:\r\n        #加速因子初始化为0.02\r\n        acc = 0.02\r\n    \r\n    #更新前期PSAR参数，为下一个交易日PSAR的计算做准备\r\n    context.pre_EP = EP\r\n    context.pre_PSAR = PSAR\r\n    context.pre_acc = acc\r\n    context.pre_trend = trend\r\n    # log.info('PSAR: %f' % (PSAR))\r\n    # log.info('trend: %s' % (trend))\r\n    \r\n    #如果是上涨行情\r\n    if trend == 'bull':        \r\n        #使用所有现金买入证券        \r\n        order_value(context.security,context.portfolio.available_cash)        \r\n    \r\n    #如果是下跌行情且持有股票      \r\n    if trend == 'bear' and context.portfolio.portfolio_value > 0:        \r\n        #卖出所有证券        \r\n        order_target(context.security,0)        \r\n        #记录这次卖出        \r\n        log.info(\"卖出 %s\" % (context.security))",
        "capital_base": 1000000,
        "run_env": "py35",
        "modified": "2019-01-08T10:55:29",
        "end_date": "2018-12-31",
        "algo_gen_method": "MANUAL",
        "created": "2019-01-08T10:55:23",
        "frequency": "DAILY",
        "id": "5c34111b5919f2000cf32dea",
        "style": "NORMAL",
        "simu_on": false,
        "stock_market": "STOCK",
        "start_run_time": "2019-01-08T10:55:23",
        "status": "SUCCESS",
        "stop_run_time": "2019-01-08T10:55:29",
        "inner": true,
        "progress": 1,
        "strategylib": true
      },
      {
        "begin_date": "2014-01-01",
        "code": "# 加速震荡指标（Accelerator Oscillator）\n\nimport talib\nimport datetime\nimport numpy as np\n\ndef init(context):\n    context.nday = 5 #短期值\n    context.mday = 20 #长期值 \n    # 定义股票池\n    context.stocks = ['600519.SH','000333.SZ','600816.SH','300072.SZ']\n    \ndef before_trading(context):\n    cash = \tcontext.portfolio.available_cash\n    date = get_datetime()\n    pass\n\ndef handle_bar(context, bar_dict):\n    for stk in context.stocks:\n        high = history(stk, ['high'], 30, '1d')['high'] #获取最高价数据\n        low = history(stk, ['low'], 30, '1d')['low'] #获取最低价数据\n        MP = np.array((high.values + low.values)/2) #计算MP = (high + low)/2\n        AO = talib.MA(MP,context.nday) - talib.MA(MP,context.mday) #计算AO值\n        AC = AO - talib.MA(AO,context.nday) # 计算AC值\n        curPosition = \tcontext.portfolio.positions[stk].amount#获取持股数量\n        shares = context.portfolio.available_cash #取得当前资金\n        # AC值自下而上穿越零轴时全仓买进\n        if AC[-1]>0 and AC[-2]<0:\n            order_value(stk,shares)\n            log.info(\"买入 %s\" % (stk))\n        # AC值自上而下下穿零轴时清仓\n        if AC[-1]<0 and AC[-2]>0 and curPosition>0:\n            order_target_value(stk,0)\n            log.info(\"卖出 %s\" % (stk))",
        "capital_base": 1000000,
        "run_env": "py35",
        "modified": "2019-01-08T10:59:12",
        "end_date": "2018-12-31",
        "algo_gen_method": "MANUAL",
        "created": "2019-01-08T10:58:59",
        "id": "5c3411f3ac17c6000cb7e302",
        "style": "NORMAL",
        "name": "加速震荡交易策略",
        "simu_on": false,
        "stock_market": "STOCK",
        "start_run_time": "2019-01-08T10:58:59",
        "status": "SUCCESS",
        "inner": true,
        "stop_run_time": "2019-01-08T10:59:12",
        "frequency": "DAILY",
        "progress": 1,
        "strategylib": true
      },
      {
        "name": "PSY交易策略",
        "simu_on": false,
        "algo_gen_method": "MANUAL",
        "id": "5c3412e875019f000ae54492",
        "created": "2019-01-08T11:03:04",
        "start_run_time": "2019-01-08T11:03:04",
        "stock_market": "STOCK",
        "stop_run_time": "2019-01-08T11:03:17",
        "style": "NORMAL",
        "inner": true,
        "capital_base": 1000000,
        "end_date": "2018-12-31",
        "status": "SUCCESS",
        "frequency": "DAILY",
        "modified": "2019-01-08T11:03:17",
        "code": "# 问财+PSY策略\r\n# 每日通过问财选股，选出的股票中，若PSY向下突破15则买入；\r\n# 在持有的股票中，若PSY向上突破85则卖出。\r\n# 此策略为日级，经简单修改可改为问财+分钟级PSY选股。\r\n# 问财语句可调整，也可进一步加入止损和最大持仓日限制。\r\n\r\n# --- 1.导入所需库包----------------------------------------------------------------\r\nimport numpy as np\r\n\r\n# --- 2.初始化账户------------------------------------------------------------------\r\ndef init(context):\r\n    context.n = 4 # 设置交易股票数量\r\n    # 使用get_iwencai函数进行智能选股\r\n    get_iwencai('PB<1，dde大单净量由大到小排名')\r\n\r\n# --- 3.自定义PSY函数----------------------------------------------------------\r\ndef PSY_cal(prices, timeperiod=12):\r\n    PSY = np.zeros(len(prices))\r\n    for i in range(len(PSY)):\r\n        PSY[i] = np.nan\r\n    if len(prices) <= timeperiod:\r\n        return PSY\r\n    for i in range(timeperiod, len(prices)):\r\n        PSY[i] = 0\r\n        for j in range(timeperiod):\r\n            if prices[i-j] > prices[i-j-1]:\r\n                PSY[i] += 1\r\n        PSY[i] *= 100/timeperiod\r\n    return PSY\r\n\r\n# --- 4. 盘中设置买卖条件，每个交易频率（日/分钟）调用一次-------------\r\ndef handle_bar(context, bar_dict):\r\n    # 卖出股票\r\n    for stock in list(context.portfolio.stock_account.positions.keys()):\r\n        # 获取股票收盘价数据\r\n        values = history(stock, ['close'], 14, '1d', False, None)\r\n        if values.empty or len(values) < 14:\r\n            continue\r\n        # 计算PSY值\r\n        PSY = PSY_cal(values['close'].values, timeperiod=12)\r\n        # 若PSY向上突破85，则卖出股票\r\n        if PSY[-2] < 85 and PSY[-1] > 85:\r\n            order_target(stock, 0)\r\n    \r\n    # 买入股票\r\n    for stock in context.iwencai_securities:\r\n        # 若股票数量到达限制，则跳出\r\n        if len(list(context.portfolio.stock_account.positions.keys())) >= context.n:\r\n            break\r\n        if stock not in list(context.portfolio.stock_account.positions.keys()):\r\n            # 获取股票收盘价数据\r\n            values = history(stock, ['close'], 14, '1d', False, None)\r\n            if values.empty or len(values) < 14:\r\n                continue\r\n            # 计算PSY值\r\n            PSY = PSY_cal(values['close'].values, timeperiod=12)\r\n            # 若PSY向下突破15，则买入1/n仓位的股票\r\n            if PSY[-2] > 15 and PSY[-1] < 15:\r\n                order_target_percent(stock, 1/context.n)\r\n",
        "begin_date": "2014-01-01",
        "progress": 1,
        "run_env": "py35",
        "strategylib": true
      },
      {
        "name": "SMA移动均线入门",
        "stop_run_time": "2019-01-08T11:07:26",
        "start_run_time": "2019-01-08T11:07:12",
        "style": "NORMAL",
        "modified_by": "hxquantdclient",
        "code": "# 导入库包\nimport talib\nimport numpy as np\nimport pandas as pd\n\n# 初始化证券账户及策略信息\ndef init(context):\n    # 设置要交易的股票池\n    context.stk = '000002.SZ'\n    # 设置参照基准\n    set_benchmark(context.stk)\n    # 设置获取历史数据的时间周期\n    g.period = 10\n\n    \n# 该函数用来定时执行买卖条件，每个交易频率（日/分钟）自动调用一次.\ndef handle_bar(context, bar_dict):\n    # 获取过去g.period天的历史行情数据\n    price = history(context.stk, ['close','high','low'], g.period, '1d', False, 'pre', is_panel=0)\n    # 获取收盘价数据\n    close = price['close'].values\n    # 计算SMA\n    SMA = talib.SMA(close,g.period)\n    # 获取当前的股票价格\n    crtprice = \tbar_dict[context.stk].open\n    # 获取当前个股的持仓\n    curposition = context.portfolio.positions[context.stk].amount\n    # 若开盘价上穿均线，且持仓为0,则全仓买入\n    if crtprice > SMA[-1] and curposition == 0:\n        order_target_percent(context.stk,1)\n        print('买入价格：'+str(crtprice))\n    # 若开盘价下穿均线，且有持仓，则清仓\n    if crtprice < SMA[-1] and curposition !=0:\n        order_target_percent(context.stk,0)\n        print('卖出价格：'+str(crtprice))\n    # 绘图\n    record(SMA = SMA[-1], crtprice = crtprice )",
        "capital_base": 1000000,
        "frequency": "DAILY",
        "status": "SUCCESS",
        "simu_on": false,
        "begin_date": "2014-01-01",
        "benchmark": "000002.SZ",
        "created": "2019-01-08T11:07:12",
        "algo_gen_method": "MANUAL",
        "id": "5c3413e0fa25f1000a07661c",
        "inner": true,
        "modified": "2019-01-08T11:07:26",
        "end_date": "2018-12-31",
        "stock_market": "STOCK",
        "progress": 1,
        "run_env": "py35",
        "strategylib": true
      }
    ]
  },
  {
    "folder_id": "4",
    "name": "多因子选股",
    "children": [
      {
        "name": "多因子alpha",
        "begin_date": "2014-01-01",
        "progress": 1,
        "frequency": "DAILY",
        "id": "5c3418c15919f2000cf32df9",
        "simu_on": false,
        "end_date": "2018-12-31",
        "start_run_time": "2019-01-08T11:28:01",
        "style": "NORMAL",
        "created": "2019-01-08T11:28:01",
        "code": "'''\r\n策略名: 多因子Alpha策略\r\n作者: edward07t\r\n'''\r\nimport numpy as np\r\nimport pandas as pd\r\n# 初始化函数 #######################################################################\r\ndef init(context):\r\n\r\n    context.last_date = ''\r\n    context.hold_max = 30\r\n    run_monthly(func=func_run_monthly, date_rule=-1)\r\n\r\n\r\n# 月末调仓函数 #######################################################################\r\ndef func_run_monthly(context, bar_dict):\r\n    # 获取昨日日期\r\n    date = get_last_datetime().strftime('%Y%m%d')\r\n    # 获取上个月末调仓日期\r\n    context.last_date = func_get_end_date_of_last_month(date)\r\n    \r\n    log.info('############################## ' + str(date) + ' ###############################')\r\n    \r\n    # 获取所有A股股票代码\r\n    securities = list(get_all_securities('stock', date).index)\r\n    \r\n    # 获取pb, pe, ps财务因子为正的股票\r\n    q = query(\r\n            valuation.symbol,\r\n            valuation.pb,\r\n            valuation.ps_ttm,\r\n            valuation.pe_ttm\r\n        ).filter(\r\n            valuation.pb > 0,\r\n            valuation.ps_ttm > 0,\r\n            valuation.pe_ttm > 0,\r\n            valuation.symbol.in_(securities)\r\n        )\r\n    df = get_fundamentals(q, date)\r\n    securities = list(df['valuation_symbol'].values)\r\n    \r\n    \r\n    # 计算过去一个月的股价动量、成交金额、ST信息\r\n    values = get_price(securities, context.last_date, date, '1d', ['close','turnover','is_st'], skip_paused = False, fq = 'pre', is_panel = 0)\r\n    \r\n    momentum = []\r\n    turnover = []\r\n    st = []\r\n    for stock in securities:\r\n        try:\r\n            momentum.append((values[stock]['close'][-1] - values[stock]['close'][0]) / values[stock]['close'][0])\r\n            turnover.append(values[stock]['turnover'].sum())\r\n            st.append(values[stock]['is_st'][-1])\r\n        except:\r\n            log.info('数据缺失:  %s' % stock)\r\n            momentum.append(None)\r\n            turnover.append(None)\r\n            st.append(None)\r\n    \r\n    df['momentum'] = np.array(momentum)\r\n    df['turnover'] = np.array(turnover)\r\n    df['is_st'] = np.array(st)\r\n    \r\n    # 去掉ST和成交金额为0的股票\r\n    df[df['is_st'] == 1] = None\r\n    df[df['turnover'] == 0] = None\r\n    df = df.dropna()\r\n    \r\n    \r\n    # 去极值\r\n    df = winsorize(df, 'valuation_pb', 20).copy()\r\n    df = winsorize(df, 'valuation_ps_ttm', 20).copy()\r\n    df = winsorize(df, 'valuation_pe_ttm', 20).copy()\r\n    df = winsorize(df, 'momentum', 20).copy()\r\n    df = winsorize(df, 'turnover', 20).copy()\r\n    df = df.dropna()\r\n    \r\n    \r\n    # 为全部A股打分，综合得分越小越好\r\n    df['scores'] = 0\r\n    \r\n    list_pb = list(df.sort_values(['valuation_pb'], ascending = True)['valuation_symbol'].values)\r\n    func_scores(df, list_pb)\r\n    list_ps = list(df.sort_values(['valuation_ps_ttm'], ascending = True)['valuation_symbol'].values)\r\n    func_scores(df, list_ps)\r\n    list_pe = list(df.sort_values(['valuation_pe_ttm'], ascending = True)['valuation_symbol'].values)\r\n    func_scores(df, list_pe)\r\n    list_mo = list(df.sort_values(['momentum'], ascending = True)['valuation_symbol'].values)\r\n    func_scores(df, list_mo)\r\n    list_to = list(df.sort_values(['turnover'], ascending = True)['valuation_symbol'].values)\r\n    func_scores(df, list_to)\r\n    \r\n    \r\n    # 根据股票综合得分为股票排序\r\n    context.selected = list(df.sort_values(['scores'], ascending = True)['valuation_symbol'].values)\r\n    \r\n    # 买入挑选的股票\r\n    func_do_trade(context, bar_dict)\r\n    \r\n    context.last_date = date\r\n\r\n\r\n#### 每日检查止损条件\r\ndef handle_bar(context, bar_dict):\r\n    \r\n    last_date = get_last_datetime().strftime('%Y%m%d')\r\n    if last_date != context.last_date and len(list(context.portfolio.stock_account.positions.keys())) > 0:\r\n        # 如果不是调仓日且有持仓，判断止损条件\r\n        func_stop_loss(context, bar_dict)\r\n\r\n\r\n################## 以下为功能函数, 在主要函数中调用 ##########################\r\n\r\n#### 1. 获取上月月末日期 #####################################################\r\ndef func_get_end_date_of_last_month(current_date):\r\n    trade_days = list(get_trade_days(None, current_date, count=30))\r\n    \r\n    for i in range(len(trade_days)):\r\n        trade_days[i] = trade_days[i].strftime('%Y%m%d')\r\n    \r\n    for date in reversed(trade_days):\r\n        if date[5] != current_date[5]:\r\n            return date\r\n    \r\n    log.info('Cannot find the end date of last month.')\r\n    return\r\n\r\n\r\n#### 2. 中位数去极值函数 ####################################################\r\ndef winsorize(df, factor, n=20):\r\n    '''\r\n    df为bar_dictFrame数据\r\n    factor为需要去极值的列名称\r\n    n 为判断极值上下边界的常数\r\n    '''\r\n    ls_raw = np.array(df[factor].values)\r\n    ls_raw.sort(axis = 0)\r\n    # 获取中位数\r\n    D_M = np.median(ls_raw)\r\n    \r\n    # 计算离差值\r\n    ls_deviation = abs(ls_raw - D_M)\r\n    ls_deviation.sort(axis = 0)\r\n    # 获取离差中位数\r\n    D_MAD = np.median(ls_deviation)\r\n    \r\n    # 将大于中位数n倍离差中位数的值赋为NaN\r\n    df.loc[df[factor] >= D_M + n * D_MAD, factor] = None\r\n    # 将小于中位数n倍离差中位数的值赋为NaN\r\n    df.loc[df[factor] <= D_M - n * D_MAD, factor] = None\r\n    \r\n    return df\r\n\r\n\r\n#### 3. 按因子排序打分函数 #############################################################\r\ndef func_scores(df, ls):\r\n    '''\r\n    按照因子暴露值将股票分为20档\r\n    第一档股票综合得分+1分\r\n    第二档股票综合得分+2分\r\n    以此类推\r\n    '''\r\n    quotient = len(ls) // 20\r\n    remainder = len(ls) % 20\r\n    layer = np.array([quotient]*20)\r\n    \r\n    for i in range(0, remainder):\r\n        layer[-(1+i)] += 1\r\n    \r\n    layer = np.insert(layer, 0, 0)\r\n    layer = layer.cumsum()\r\n    \r\n    for i in range(0,20):\r\n        for j in range(layer[i], layer[i+1]):\r\n            df.loc[df['valuation_symbol'] == ls[j], 'scores'] += (i + 1)\r\n\r\n\r\n#### 4.下单函数 ###################################################################\r\ndef func_do_trade(context, bar_dict):\r\n    # 先清空所有持仓\r\n    if len(list(context.portfolio.stock_account.positions.keys())) > 0:\r\n        for stock in list(context.portfolio.stock_account.positions.keys()):\r\n            order_target(stock, 0)\r\n    \r\n    # 买入前30支股票\r\n    for stock in context.selected:\r\n        order_target_percent(stock, 1./context.hold_max)\r\n        if len(list(context.portfolio.stock_account.positions.keys())) >= context.hold_max:\r\n            break\r\n    return\r\n\r\n\r\n#### 5.止损函数 ####################################################################\r\ndef func_stop_loss(context, bar_dict):\r\n    #获取账户持仓信息\r\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \r\n    if len(holdstock) > 0:\r\n        num = -0.1\r\n        for stock in holdstock:\r\n            close = history(stock,['close'],1,'1d').values\r\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\r\n                order_target(stock,0)\r\n                log.info('股票{}已止损'.format(stock))\r\n    \r\n    \r\n    #获取账户持仓信息\r\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \r\n    if len(holdstock) > 0:\r\n        num = - 0.13\r\n        T = history('000001.SH',['quote_rate'],7,'1d').values.sum()\r\n        if T < num*100:\r\n            log.info('上证指数连续三天下跌{}已清仓'.format(T))\r\n            for stock in holdstock:\r\n                order_target(stock,0)\r\n    \r\n            ",
        "inner": true,
        "algo_gen_method": "MANUAL",
        "status": "SUCCESS",
        "stop_run_time": "2019-01-08T11:53:59",
        "modified": "2019-01-08T11:53:59",
        "capital_base": 1000000,
        "stock_market": "STOCK",
        "run_env": "py35",
        "strategylib": true,
        "libresearchinfo": {
          "share_filename": "63855dbee9f6c22e638f0b921ae3dc93.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/385045923/63855dbee9f6c22e638f0b921ae3dc93.html",
          "clone_count": 0,
          "user_id": "385045923",
          "id": "5c355d78b47299000a6eb5aa",
          "path": "已完成/多因子Alpha策略.ipynb"
        }
      },
      {
        "name": "三因子选股模型",
        "simu_on": false,
        "created": "2019-01-08T11:22:17",
        "code": "'''\n# 一个简单的三因子模型\n# 作者：eric_xcfj\n'''\n\nimport pandas as pd\nimport numpy as np\nimport datetime\n\ndef init(context):\n    # 使用智能选股函数设置股票池 \n    get_iwencai('沪深300')\n    # 设置最大持股数\n    \n    context.max_stocks = 10 \n    # 设置调仓周期，每月第二个交易日运行\n    run_monthly(reallocation,date_rule=1)\n\ndef reallocation(context, bar_dict):\n    # 每个调仓日先清仓持有的股票\n    for security in list(context.portfolio.stock_account.positions.keys()):\n        order_target(security, 0)\n    # 首先获得当前日期\n    time = get_datetime()\n    date = time.strftime('%Y%m%d')\n    # 获得股票池列表\n    sample = context.iwencai_securities\n    # 创建字典用于存储因子值\n    df = {'security':[], 1:[], 2:[], 3:[], 'score':[]}\n    \n    # 因子选择\n    for security in sample:\n        q=query(\n            profit.roic,# 投资回报率\n            valuation.pb,# 市净率\n            valuation.ps_ttm,# 市销率\n        ).filter(\n            profit.symbol==security\n        )\n        \n        # 缺失值填充为0\n        fdmt = get_fundamentals(q, date=date).fillna(0)\n        \n        # 判断是否有数据\n        if (not (fdmt['profit_roic'].empty or\n                fdmt['valuation_pb'].empty or\n                fdmt['valuation_ps_ttm'].empty)):\n            # 计算并填充因子值\n            df['security'].append(security)\n            df[1].append(fdmt['profit_roic'][0])# 因子1：投资回报率\n            df[2].append(fdmt['valuation_pb'][0])# 因子2：市净率\n            df[3].append(fdmt['valuation_ps_ttm'][0])#因子3：市销率\n    \n    for i in range(1, 4):\n        # 因子极值处理，中位数去极值法\n        m = np.mean(df[i])\n        s = np.std(df[i])\n        for j in range(len(df[i])):\n            if df[i][j] <= m-3*s:\n                df[i][j] = m-3*s\n            if df[i][j] >= m+3*s:\n                df[i][j] = m+3*s\n        m = np.mean(df[i])\n        s = np.std(df[i])\n        \n        # 因子无量纲处理，标准化法\n        for j in range(len(df[i])):\n            df[i][j] = (df[i][j]-m)/s\n    \n    # 计算综合因子得分\n    for i in range(len(df['security'])):\n        # 等权重计算(注意因子方向)\n        s = (df[1][i]-df[2][i]-df[3][i])\n        df['score'].append(s)\n        \n    # 按综合因子得分由大到小排序\n    df = pd.DataFrame(df).sort_values(by ='score', ascending=False)\n\n    # 等权重分配资金\n    cash = context.portfolio.available_cash/context.max_stocks\n    \n    # 买入新调仓股票\n    for security in df[:context.max_stocks]['security']:\n        order_target_value(security, cash)\n    \n",
        "stop_run_time": "2019-01-08T11:24:21",
        "frequency": "DAILY",
        "id": "5c34176975019f000ae54499",
        "run_env": "py35",
        "modified": "2019-01-08T11:24:21",
        "status": "SUCCESS",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "style": "NORMAL",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T11:22:17",
        "end_date": "2018-12-31",
        "progress": 1,
        "inner": true,
        "stock_market": "STOCK",
        "strategylib": true
      },
      {
        "name": "因子选股-打分模型",
        "status": "SUCCESS",
        "id": "5c343584ac17c6000cb7e317",
        "frequency": "DAILY",
        "capital_base": 1000000,
        "code": "from datetime import timedelta, date\n#1.导入时间数据包\nimport pandas as pd\n#2.导入pandas数据包，快捷使用为pd\n# 初始化函数 ##################################################################\ndef init(context):\n    context.n = 30 # 最大持股数\n    #调仓月份设置，为1-12月\n    context.trade_date = range(1,13,1)\n    ## 按月调仓，调仓日为月末最后一个交易日\n    run_monthly(trade,date_rule=2)\n    #运用I问财进行股票筛选\n    get_iwencai('未停牌,上市时间超过2年')\n    \n# 每日检查止损条件 #############################################################\ndef handle_bar(context,bar_dict):\n    \n    #获取账户持仓信息\n    holdstock = list(context.portfolio.stock_account.positions.keys()) \n    if len(holdstock) > 0:\n        num = -0.1\n        for stock in holdstock:\n            close = history(stock,['close'],1,'1d').values\n            if close/context.portfolio.positions[stock].last_price -1 <= num:\n                order_target(stock,0)\n                log.info('股票{}已止损'.format(stock))\n                \n# 1. 筛选股票列表\ndef stocks_jz(context,bar_dict):\n    # 创建字典用于存\n    time = get_datetime()\n    date = time.strftime('%Y%m%d')\n    df = {'security': [], 1:[], 2:[], 3:[], 'score':[]}\n    stocks=context.iwencai_securities\n    for security in stocks:\n        q=query(\n            profit.symbol,\n            valuation.pe_ttm,# 市盈率\n            valuation.pb,# 市净率\n            valuation.ps_ttm,# 市销率\n        ).filter(\n            profit.symbol==security\n        )\n        \n        # 缺失值填充为0\n        yz = get_fundamentals(q, date=date).fillna(0)\n        df['security'].append(security)\n        # 判断是否有数据\n        if (not (yz['valuation_pe_ttm'].empty or\n                yz['valuation_ps_ttm'].empty or\n                yz['valuation_pb'].empty)):\n            if yz['valuation_pe_ttm'][0]<33 :\n                df[1].append(10)\n            else:\n                df[1].append(0)\n            if yz['valuation_ps_ttm'][0]<2.01:\n                df[2].append(10)\n            elif yz['valuation_ps_ttm'][0]<10.01 and yz['valuation_ps_ttm'][0]>2.01:\n                df[2].append(5)\n            else:\n                df[2].append(0)\n            if yz['valuation_pb'][0]<1.01:\n                df[3].append(10)\n            elif yz['valuation_pb'][0]<3.01 and yz['valuation_pb'][0]>1.01:\n                df[3].append(5)\n            else:\n                df[3].append(0)\n        else:\n            df[1].append(0)\n            df[2].append(0)\n            df[3].append(0)\n        # 计算综合因子得分\n    for i in range(len(df['security'])):\n        # 等权重计算(注意因子方向)\n        s = (df[1][i]+df[2][i]+df[3][i])\n        df['score'].append(s)\n        # 由小到大排序\n    df = pd.DataFrame(df).sort_values(by ='score', ascending=False)\n    context.sample = df['security'][:30]\n    return context.sample\ndef trade(context, bar_dict):\n    date = get_datetime()\n    months = get_datetime().month\n    if months in context.trade_date:\n        ##获得50只股票列表\n        jz_list = stocks_jz(context,bar_dict)\n        ## 获得满足每种条件的股票池\n        stock_list = list(set(jz_list))\n        ## 卖出\n        if len(list(context.portfolio.stock_account.positions.keys())) > 0:\n            for stock in list(context.portfolio.stock_account.positions.keys()) :\n                if stock not in stock_list:\n                    order_target(stock, 0)\n        ## 买入\n        if len(stock_list) > 0:\n            for stock in stock_list:\n                if stock not in list(context.portfolio.stock_account.positions.keys()) :\n                    if len(list(context.portfolio.stock_account.positions.keys()) ) < context.n :\n                        number = context.n  - len(list(context.portfolio.stock_account.positions.keys()) )\n                        order_value(stock,context.portfolio.stock_account.available_cash/number)\n                    else: \n                        order_value(stock,context.portfolio.stock_account.available_cash)\n    ",
        "stock_market": "STOCK",
        "modified": "2019-01-08T13:48:18",
        "start_run_time": "2019-01-08T13:30:44",
        "begin_date": "2014-01-01",
        "simu_on": false,
        "stop_run_time": "2019-01-08T13:48:18",
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "progress": 1,
        "inner": true,
        "created": "2019-01-08T13:30:44",
        "run_env": "py35",
        "algo_gen_method": "MANUAL",
        "strategylib": true
      }
    ]
  },
  {
    "folder_id": "5",
    "name": "形态策略",
    "children": [
      {
        "name": "breakaway脱离形态",
        "begin_date": "2014-01-01",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "modified": "2019-01-08T13:40:28",
        "simu_on": false,
        "modified_by": "hxquantdclient",
        "start_run_time": "2019-01-08T13:39:27",
        "progress": 1,
        "inner": true,
        "benchmark": "000001.SH",
        "run_env": "py35",
        "end_date": "2018-12-31",
        "created": "2019-01-08T13:39:27",
        "id": "5c34378f6158be000a0db1dc",
        "style": "NORMAL",
        "status": "SUCCESS",
        "stock_market": "STOCK",
        "stop_run_time": "2019-01-08T13:40:28",
        "code": "'''\n形态名称：Breakaway 脱离\n描述：五日K线模式，以看涨脱离为例，下跌趋势中，第一日长阴线，第二日跳空阴线延续趋\n势开始震荡，第五日长阳线，收盘价在第一天收盘价与　第二天开盘价之间预示价格上涨。\n\n作者:一箩筐\n'''\nimport talib as tl\nimport datetime\n# 初始化函数 ###################################################################\ndef init(context):\n    set_params(context)                             # 设置策略常量\n    set_variables(context)                          # 设置中间变量\n    set_backtest(context)                           # 设置回测条件\n#1.设置策略参数\ndef set_params(context):\n    context.holdMax = 2                             #最大持有股票数\n    context.periods = 5                             #持有天数\n#2.设置中间变量\ndef set_variables(context):\n    context.Count = 0                               #当前持仓数\n    context.hold_days = {}                          #各股票持仓时间\n#3.设置回测条件\ndef set_backtest(context):\n    set_benchmark('000001.SH')                      # 设置基准\n    set_slippage(PriceSlippage(0.002))              # 设置可变滑点\n    \n\n# 每日开盘执行###################################################################\ndef handle_bar(context,bar_dict):\n    # 获得卖出股票池\n    sell_stocks = stocks_to_sell(context)\n\n    # 获得买入股票池\n    buy_stocks = stocks_to_buy(context,bar_dict)\n    \n    # 交易操作\n    trade_stocks(sell_stocks,buy_stocks,context)\n\n\n#4.获得卖出股票池\ndef stocks_to_sell(context):\n    sell_stocks = []\n    # 持仓到期股票\n    for stock in context.hold_days:\n        if context.hold_days[stock]>context.periods:\n            sell_stocks.append(stock)\n    # 更新当前持仓数\n    context.Count = len(list(context.portfolio.stock_account.positions.keys()))-len(sell_stocks)    \n    return sell_stocks\n#5.获得买入股票池\ndef stocks_to_buy(context,bar_dict,):\n    CDLBREAKAWAY_stocks = []\n    # 持仓数未达上限\n    if context.Count < context.holdMax:    \n        # 获取初始股票池\n        stocks = get_raw_stocks(bar_dict)\n        # 挑选CDLBREAKAWAY形态股票\n        CDLBREAKAWAY_stocks = get_CDLBREAKAWAY_stocks(stocks,bar_dict)\n    return CDLBREAKAWAY_stocks\n#6.获取初始股票池\ndef get_raw_stocks(bar_dict):\n    tdate = get_datetime().strftime(\"%Y%m%d\") #当天日期\n    today_datetime = datetime.datetime.strptime(tdate,\"%Y%m%d\")\n    yesterday_time = get_datetime()-datetime.timedelta(days=1)\n    yesterday_date = yesterday_time.strftime(\"%Y%m%d\") #昨日日期\n    \n    # 获取所有股票\n    stocks = get_all_securities(\"stock\",tdate)\n    # 排除新股\n    stocks = stocks[(today_datetime- stocks.start_date) > datetime.timedelta(60)].index.values\n    # 排除停牌股票\n    stocks = [stock for stock in stocks if bar_dict[stock].is_paused == 0]\n    # 排除开盘涨跌停\n    stocks = [stock for stock in stocks if bar_dict[stock].open!= bar_dict[stock].high_limit\n    and bar_dict[stock].open!= bar_dict[stock].low_limit]\n    # 排除st\n    stocks = [stock for stock in stocks if bar_dict[stock].is_st == 0]\n    \n    return stocks\n#7.挑选CDLBREAKAWAY形态股票\ndef get_CDLBREAKAWAY_stocks(stocks,bar_dict):\n    CDLBREAKAWAY_stocks = []\n    for stock in stocks:\n        value = history(stock, ['open','high','low','close'], 20, '1d', True)\n        open_P = value.open.values\n        high = value.high.values\n        low = value.low.values\n        close = value.close.values\n        try:\n            integer = tl.CDLBREAKAWAY(open_P, high, low, close)\n            is_CDLBREAKAWAY = integer[-1]\n        # 跳过无数据的股票\n        except:\n            log.info(stock+\"无数据\")\n            continue\n        if is_CDLBREAKAWAY!=0:\n            CDLBREAKAWAY_stocks.append(stock)\n    return CDLBREAKAWAY_stocks\n#8.交易操作\ndef trade_stocks(sell_stocks,buy_stocks,context):\n    # 卖出操作\n    for stock in sell_stocks:\n        order_target_value(stock,0)\n    # 每股资金\n    Count = max([1,len(buy_stocks)])\n    one_cash = context.portfolio.stock_account.available_cash/Count\n    # 买入操作\n    for stock in buy_stocks:\n        order_target_value(stock,one_cash)\n        context.hold_days[stock]= 0\n        \n        \n# 盘后计算###################################################################\ndef after_trading_end(context, bar_dict):\n    # 持仓天数增加\n    for stock in context.hold_days:\n        context.hold_days[stock]+=1\n    ",
        "frequency": "DAILY",
        "strategylib": true
      },
      {
        "name": "三浪下跌形态",
        "begin_date": "2014-01-01",
        "algo_gen_method": "MANUAL",
        "capital_base": 1000000,
        "modified": "2019-01-08T13:44:53",
        "simu_on": false,
        "modified_by": "hxquantdclient",
        "start_run_time": "2019-01-08T13:44:17",
        "progress": 1,
        "inner": true,
        "benchmark": "000001.SH",
        "run_env": "py35",
        "end_date": "2018-12-31",
        "created": "2019-01-08T13:44:17",
        "id": "5c3438b175019f000c97f7e7",
        "style": "NORMAL",
        "status": "SUCCESS",
        "stock_market": "STOCK",
        "stop_run_time": "2019-01-08T13:44:53",
        "code": "'''\n三浪下跌形态:\n第五天下跌幅度大于4%\n第四天上涨，但幅度小于3%，\n第三天不管下跌还是上涨，但涨幅不能超过1%，\n第二天下跌幅度超过2%，\n最近一天下跌幅度超过1%，\n\n每股盈利大于0,防止下跌是股票本身存在问题\n五日持仓\n\n'''\nimport talib as tl\nimport datetime\n\n############################## 以下为主要函数  ################################\n#initialize()\n#handle_bar_dict()\n#after_trading_end()\n\n\n# 初始化函数 ###################################################################\ndef init(context):\n    set_params(context)                             # 设置策略常量\n    set_variables(context)                          # 设置中间变量\n    set_backtest(context)                           # 设置回测条件\n    get_iwencai('每股盈利大于0','i_stocks')\n#1.设置策略参数\ndef set_params(context):\n    context.holdMax = 2                             #最大持有股票数\n    context.periods = 5                             #持有天数\n#2.设置中间变量\ndef set_variables(context):\n    context.Count = 0                               #当前持仓数\n    context.hold_days = {}                          #各股票持仓时间\n#3.设置回测条件\ndef set_backtest(context):\n    set_benchmark('000001.SH')                      # 设置基准\n    set_slippage(PriceSlippage(0.002))              # 设置可变滑点\n    \n\n# 每日开盘执行###################################################################\ndef handle_bar(context,bar_dict):\n    # 获得卖出股票池\n    sell_stocks = stocks_to_sell(context)\n\n    # 获得买入股票池\n    buy_stocks = stocks_to_buy(context,bar_dict)\n    \n    # 交易操作\n    trade_stocks(sell_stocks,buy_stocks,context)\n\n\n#4.获得卖出股票池\ndef stocks_to_sell(context):\n    sell_stocks = []\n    # 持仓到期股票\n    for stock in context.hold_days:\n        if context.hold_days[stock]>context.periods:\n            sell_stocks.append(stock)\n    # 更新当前持仓数\n    context.Count = len(list(context.portfolio.stock_account.positions.keys()))-len(sell_stocks)    \n    return sell_stocks\n#5.获得买入股票池\ndef stocks_to_buy(context,bar_dict):\n    CDLBREAKAWAY_stocks = []\n    # 持仓数未达上限\n    if context.Count < context.holdMax:    \n        # 获取初始股票池\n        stocks = get_raw_stocks(bar_dict)\n        stocks = [stk for stk in stocks if stk in context.i_stocks]\n        # 挑选CDLBREAKAWAY形态股票\n        CDLBREAKAWAY_stocks = get_CDLBREAKAWAY_stocks(stocks,bar_dict)\n    return CDLBREAKAWAY_stocks\n#6.获取初始股票池\ndef get_raw_stocks(bar_dict):\n    tdate = get_datetime().strftime(\"%Y%m%d\") #当天日期\n    today_datetime = datetime.datetime.strptime(tdate,\"%Y%m%d\")\n    yesterday_time = get_datetime()-datetime.timedelta(days=1)\n    yesterday_date = yesterday_time.strftime(\"%Y%m%d\") #昨日日期\n    \n    # 获取所有股票\n    stocks = get_all_securities(\"stock\",tdate)\n    # 排除新股\n    stocks = stocks[(today_datetime- stocks.start_date) > datetime.timedelta(60)].index.values\n    # 排除停牌股票\n    stocks = [stock for stock in stocks if bar_dict[stock].is_paused == 0]\n    # 排除开盘涨跌停\n    stocks = [stock for stock in stocks if bar_dict[stock].open!= bar_dict[stock].high_limit\n    and bar_dict[stock].open!= bar_dict[stock].low_limit]\n    # 排除st\n    stocks = [stock for stock in stocks if bar_dict[stock].is_st == 0]\n    \n    return stocks\n#7.挑选三浪下跌形态股票\ndef get_CDLBREAKAWAY_stocks(stocks,bar_dict):\n    Waves_fall_stocks = []\n    for stock in stocks:\n        value = history(stock, ['close'],6,'1d',True)\n        roc_array = value['close'].pct_change().dropna().values\n        try:\n            if roc_array[0]<-0.05 and roc_array[1]>0 and roc_array[1]<0.04 and\\\n            roc_array[2]<0.01 and roc_array[3]<-0.02 and roc_array[4]<-0.01:\n                Waves_fall_stocks.append(stock)\n        # 跳过无数据的股票\n        except:\n            log.info(stock+\"无数据\")\n            continue\n    return Waves_fall_stocks\n#8.交易操作\ndef trade_stocks(sell_stocks,buy_stocks,context):\n    # 卖出操作\n    for stock in sell_stocks:\n        order_target_value(stock,0)\n    # 每股资金\n    Count = max([1,len(buy_stocks)])\n    one_cash = context.portfolio.stock_account.available_cash/Count\n    # 买入操作\n    for stock in buy_stocks:\n        order_target_value(stock,one_cash)\n        context.hold_days[stock]= 0\n        \n        \n# 盘后计算###################################################################\ndef after_trading_end(context, bar_dict):\n    # 持仓天数增加\n    for stock in context.hold_days:\n        context.hold_days[stock]+=1\n    ",
        "frequency": "DAILY",
        "strategylib": true
      }
    ]
  },
  {
    "folder_id": "6",
    "name": "量化择时",
    "children": [
      {
        "name": "RSRS指标择时及大小盘轮动",
        "style": "NORMAL",
        "algo_gen_method": "MANUAL",
        "begin_date": "2014-01-01",
        "benchmark": "000300.SH",
        "status": "SUCCESS",
        "modified_by": "hxquantdclient",
        "code": "'''\r\nRSRS指标择时及大小盘轮动\r\n作者:一箩筐\r\n\r\n简介:\r\nRSRS指标的构建\r\n1）取前N日的最高价序列与最低价序列。\r\n2）将两列数据,以最高价为因变量，最低价为自变量进行OLS线性回归。\r\n3）取前M日的斜率时间序列，计算当日斜率的标准分z。\r\n4）将z与拟合方程的决定系数相乘，作为当日RSRS指标值。\r\n\r\n择沪深300和中证500的ETF作为交易标的，作大小盘风格轮动择时。\r\n\r\n交易信号判断\r\n1）以RSRS指标值大的作为交易标的;\r\n2）若RSRS指标上穿阈值S，则开仓买入；（S为开平仓阈值）\r\n3）若RSRS指标下穿阈值-S，则平仓;\r\n4）若RSRS指标在-S和S中间时，两标的的RSRS相对大小变化，则表示风格轮动，换仓，否则不交易。\r\n'''\r\n\r\n\r\nimport numpy as np\r\nimport statsmodels.api as sm\r\n\r\n# 初始化函数 ##################################################################\r\ndef init(context):\r\n    set_params(context)                      # 设置策略参数\r\n    set_variables()                          # 设置中间变量\r\n    set_backtest()                           # 设置回测条件\r\n#1.设置策略参数\r\ndef set_params(context):\r\n    context.N = 20                           # 取前N日的数据\r\n    context.M = 400                          # RSRS指标M变量\r\n    context.stk1 = '510300.OF'               # 沪深300(大盘)\r\n    context.stk2 = '510500.OF'               # 中证500(小盘)\r\n    context.S = 0.8\r\n#2.设置中间变量\r\ndef set_variables():\r\n    pass\r\n#3.设置回测条件\r\ndef set_backtest():\r\n    set_benchmark('000300.SH')               # 设置基准\r\n    set_slippage(PriceSlippage(0.002))       # 设置可变滑点\r\n\r\n# 每日执行函数 ##################################################################\r\ndef handle_bar(context,bar_dict):\r\n    \r\n    # 计算交易信号\r\n    signals = trade_signal(context,bar_dict)\r\n    log.info(signals)\r\n    # 交易操作\r\n    trade_operation(context,signals)\r\n    \r\n#4.计算交易信号\r\ndef trade_signal(context,bar_dict):\r\n    N = context.N\r\n    M = context.M\r\n    # 计算单个标的昨日的RSRS\r\n    hz300_RSRS = get_RSRS(bar_dict,'000300.SH',N,M)\r\n    zz500_RSRS = get_RSRS(bar_dict,'000905.SH',N,M)\r\n    return [hz300_RSRS,zz500_RSRS]\r\n#5.计算RSRS\r\ndef get_RSRS(bar_dict,stock,n,m):\r\n    values = history(stock,['high','low'],n+m-1,'1d', skip_paused=True)\r\n    \r\n    high_array = values.high.values[-(n+m-1):]\r\n    low_array = values.low.values[-(n+m-1):]\r\n    scores = np.zeros(m) #各期斜率\r\n    for i in range(m):\r\n        high = high_array[i:i+30]\r\n        low = low_array[i:i+30]\r\n        \r\n        # 计算单期斜率\r\n        x = low   #low作为自变量\r\n        X = sm.add_constant(x) #添加常数变量\r\n        y = high  #high作为因变量\r\n        model = sm.OLS(y,X) #最小二乘法\r\n        results = model.fit() \r\n        score = results.params[1]\r\n        scores[i] = score\r\n        \r\n        # 记录最后一期的Rsquared(可决系数)\r\n        if i==m-1:\r\n            R_squared = results.rsquared\r\n    \r\n    # 最近期的标准分\r\n    z_score = (scores[-1]-scores.mean())/scores.std()\r\n    \r\n    # RSRS得分\r\n    RSRS_socre = z_score*R_squared\r\n    \r\n    return RSRS_socre\r\n#6.交易操作\r\ndef trade_operation(context,signals):\r\n    #RSRS大的标的 和值\r\n    signal = max(signals)\r\n    if signals[0]>signals[1]:\r\n        stock = context.stk1\r\n    else:\r\n        stock = context.stk2\r\n\r\n    if signal>context.S:\r\n        order_value(stock,context.portfolio.stock_account.available_cash*0.9)\r\n    if signal<-context.S:\r\n        order_target_percent(stock,0)\r\n    #处于中间,仓位不变，但是若风格替换且持仓则要换仓\r\n    else:\r\n        if len(list(context.portfolio.stock_account.positions.keys()))!=0:\r\n            order_value(stock,context.portfolio.stock_account.available_cash*0.9)\r\n            \r\n  ",
        "created": "2019-01-08T14:01:18",
        "progress": 1,
        "stop_run_time": "2019-01-08T14:08:18",
        "frequency": "DAILY",
        "id": "5c343caefa25f1000a07663c",
        "run_env": "py35",
        "modified": "2019-01-08T14:08:18",
        "simu_on": false,
        "capital_base": 1000000,
        "start_run_time": "2019-01-08T14:01:18",
        "end_date": "2018-12-31",
        "inner": true,
        "stock_market": "STOCK",
        "strategylib": true,
        "libresearchinfo": {
          "share_filename": "ee219cfbfa2574e0f23352a383032acb.ipynb",
          "clone_count": 0,
          "user_id": "385045923",
          "id": "5c355d8d37c44f000cb536b1",
          "path": "已完成/RSRS择时 — 光大证券.ipynb",
          "uri": "http://mindgo.10jqka.com.cn/research/users/385045923/ee219cfbfa2574e0f23352a383032acb.html"
        }
      },
      {
        "name": "单向波动差策略",
        "start_run_time": "2019-01-08T13:56:24",
        "begin_date": "2014-01-01",
        "run_env": "py35",
        "capital_base": 1000000,
        "simu_on": false,
        "created": "2019-01-08T13:56:24",
        "inner": true,
        "id": "5c343b88fa25f1000c7bbda5",
        "progress": 1,
        "algo_gen_method": "MANUAL",
        "frequency": "DAILY",
        "end_date": "2018-12-31",
        "code": "import pandas as pd\n#初始化账户       \ndef init(context):      \n    #设置要交易的股票      \n    context.security = '600519.SH'   \n#设置买卖条件，每个交易频率（日/分钟/tick）调用一次   \ndef handle_bar(context,bar_dict):\n    stk = context.security\n    # 获取过去250天的相关数据（开、高、低价格）\n    data = history(stk, ['open','high','low'], 250, '1d')\n    # 计算单向波动差值\n    dif = (data['high'] + data['low'])/data['open']-2\n    # 计算单向波动差值均值\n    dif_ma = pd.rolling_mean(dif,60)\n    # 若dif_ma为正，则买入或持仓\n    if dif_ma.values[-1] > 0:\n        order_target_percent(stk,1)\n    # 若dif_ma为负，则卖出或空仓\n    if dif_ma.values[-1] < 0 and context.portfolio.stock_account.market_value > 0:\n        order_target(stk,0)",
        "stock_market": "STOCK",
        "status": "SUCCESS",
        "style": "NORMAL",
        "modified": "2019-01-08T13:56:30",
        "stop_run_time": "2019-01-08T13:56:30",
        "strategylib": true
      },
      {
        "name": "基于奇异谱分析的均线择时策略",
        "begin_date": "2014-01-01",
        "progress": 1,
        "capital_base": 1000000,
        "start_run_time": "2019-01-08T13:52:48",
        "algo_gen_method": "MANUAL",
        "created": "2019-01-08T13:52:48",
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "modified": "2019-01-08T13:52:53",
        "status": "SUCCESS",
        "inner": true,
        "frequency": "DAILY",
        "simu_on": false,
        "run_env": "py35",
        "id": "5c343ab05919f2000bfb50f8",
        "stop_run_time": "2019-01-08T13:52:53",
        "code": "# 参考国泰君安刘富兵研报《基于奇异谱分析的均线择时研究》，交易标的为同花顺，默认参数为20日\nimport numpy as np\nimport pandas as pd\n\n# 初始化账户\ndef init(context):\n    # 设置时间周期\n    context.m = 20\n    # 设置要交易的股票\n    context.stocks = ['300033.SZ']\n\n#设置买卖条件，每个交易频率（日/分钟/tick）调用一次\ndef handle_bar(context,bar_dict):\n    num = context.m\n    for stk in context.stocks:\n        #获取股票历史收盘价数据\n        close = history(stk, ['close'], 2*num, '1d')\n        # 给c赋值收盘价数据\n        c = close['close'].values\n        #计算均线价格\n        SSA20 = SSA(close.values, num)\n        # 若收盘价与SSA均线金叉\n        if c[-1] > SSA20[-1] and  c[-2] < SSA20[-2] and stk not in list(context.portfolio.stock_account.positions.keys()):\n            #使用所有现金买入股票\n            order_target_percent(stk,1)\n\n        # 若收盘价与SSA均线死叉\n        if c[-1] < SSA20[-1] and c[-2] > SSA20[-2] and stk in list(context.portfolio.stock_account.positions.keys()):\n            #卖出所有股票\n            order_target(stk, 0)\n \n# 嵌入\ndef getWindowMatrix(inputArray, t, m):\n    temp = []\n    n = t-m+1\n    for i in range(n):\n        tmp = []\n        for j in range(m):\n            tmp.append(inputArray[i+j][0])\n        temp.append(tmp)\n    WindowMatrix = np.array(temp)\n    return WindowMatrix\n\n# 奇异谱分析，取第一主成分分量，返回重构矩阵\ndef SVDreduce(WindowMatrix):\n    u, s, v = np.linalg.svd(WindowMatrix) #svd分解\n    m1, n1 = u.shape\n    m2, n2 = v.shape\n    index = s.argmax()\n    u1 = u[:, index]\n    v1 = v[index]\n    u1 = u1.reshape((m1, 1))\n    v1 = v1.reshape((1, n2))\n    value = s.max()\n    newMatrix = value*(np.dot(u1, v1))  #重构矩阵\n    return newMatrix\n\n# 对角线平均法重构序列\ndef recreateArray(newMatrix, t, m):\n    ret = []\n    n = t-m+1\n    for p in range(1, t+1):\n        if p < m:\n            alpha = p\n        elif p > t-m+1:\n            alpha = t-p+1\n        else:\n            alpha = m\n        sigma = 0\n        for j in range(1, m+1):\n            i = p-j+1\n            if i > 0 and i < n+1:\n                sigma += newMatrix[i-1][j-1]\n        ret.append(sigma/alpha)\n    return ret\n\n# 按不同的序列、不同的窗口大小计算SSA\ndef SSA(inputArray, m):\n    t = 2*m\n    WindowMatrix = getWindowMatrix(inputArray, t, m)\n    newMatrix = SVDreduce(WindowMatrix)\n    newArray = recreateArray(newMatrix, t, m)\n    return newArray\n",
        "stock_market": "STOCK",
        "strategylib": true
      },
      {
        "name": "趋势追踪-组合指标择时",
        "stock_market": "STOCK",
        "benchmark": "000001.SH",
        "frequency": "DAILY",
        "modified_by": "hxquantdclient",
        "progress": 1,
        "capital_base": 1000000,
        "end_date": "2018-12-31",
        "run_env": "py35",
        "algo_gen_method": "MANUAL",
        "inner": true,
        "id": "5c344008a59c54000b3fd01f",
        "created": "2019-01-08T14:15:36",
        "modified": "2019-01-08T14:15:50",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T14:15:36",
        "code": "'''\r\n趋势追踪-组合指标择时\r\n作者:一箩筐\r\n\r\n简介:计算指数的SMA,MACD,DMA,TRIX指标,当出现以下情况时获得交易信号:\r\n(1)SMA金叉,signal=1;SMA死叉,signal=-1\r\n(2)MACD金叉,signal=1;MACD死叉,signal=-1\r\n(3)DMA上穿AMA,signal=1;DMA下穿AMA,signal=-1;\r\n(4)TRIX上穿MATTRIX,signal=1;TRIX下穿MATTRIX,signal=-1\r\n累计signals>=1时买入;\r\n累计signals<=-1时卖出;\r\n\r\n\r\n'''\r\n\r\nimport talib as tl\r\n\r\n############################## 以下为主要函数  ################################\r\n#initialize()\r\n#handle_bar_dict()\r\n\r\n# 初始化函数 ##################################################################\r\ndef init(context):\r\n    set_params(context)                             # 设置策略常量\r\n    set_variables(context)                          # 设置中间变量\r\n    set_backtest(context)                           # 设置回测条件\r\n    \r\n#1.设置策略参数\r\ndef set_params(context):\r\n    context.stock = '000001.SH'              # 设置要交易的指数\r\n    context.SMA_s = 4                        # 设置SMA短期均线日期\r\n    context.SMA_l = 40                       # 设置SMA长期均线日期\r\n    context.fastperiod = 12                  # 设置MACD的fastperiod\r\n    context.slowperiod = 26                  # 设置MACD的slowperiod\r\n    context.signalperiod = 9                 # 设置MACD的signalperiod\r\n    context.DMA_S = 4                        # 设置DMA的短期均线日期S\r\n    context.DMA_L = 40                       # 设置DMA的长期均线日期L\r\n    context.DMA_M = 20                       # 设置DMA的均线差值\r\n    context.TRIX_N = 20                      # 设置TRIX的N值\r\n    context.TRIX_M = 60                      # 设置TRIX的M值\r\n#2.设置中间变量\r\ndef set_variables(context):\r\n    context.signal = 0                       # 设置信号值(1或0空仓,3买入)\r\n#3.设置回测条件\r\ndef set_backtest(context):\r\n    set_benchmark('000001.SH')               # 设置基准\r\n    set_slippage(PriceSlippage(0.002))       # 设置可变滑点\r\n    \r\n    \r\n# 每日开盘执行###################################################################\r\ndef handle_bar(context,bar_dict):\r\n    # 计算交易信号\r\n    context.signal = stock_to_signals(context,bar_dict)                     \r\n    # 执行买卖操作\r\n    trade_operation(context.signal,context.stock)\r\n\r\n#4.计算SMA信号\r\ndef SMA_signal(context,bar_dict):\r\n    value = history(context.stock,['close'],200,'1d',True,'pre')\r\n    value = value.dropna()\r\n    close = value.close.values\r\n    # 计算移动均线值\r\n    sma = tl.SMA(close,context.SMA_s)\r\n    lma = tl.SMA(close,context.SMA_l)\r\n    # 判断信号\r\n    if sma[-1]>sma[-2] and sma[-1]>lma[-1] and sma[-2]<lma[-2]:\r\n        return 1\r\n    elif sma[-1]<sma[-2] and sma[-1]<lma[-1] and sma[-2]>lma[-2]:\r\n        return -1\r\n    else:\r\n        return 0\r\n#5.计算MACD信号\r\ndef MACD_signal(context,bar_dict):\r\n    value = history(context.stock,['close'],200,'1d',True,'pre')\r\n    value = value.dropna()\r\n    close = value.close.values\r\n    # 计算macd值\r\n    macd, dif, dea = tl.MACD(close,context.fastperiod,context.slowperiod,context.signalperiod)\r\n    # 判断信号\r\n    if dif[-1]>dif[-2] and dif[-1]>dea[-1] and dif[-2]<dea[-2] and dif[-1]>0:\r\n        return 1\r\n    elif dif[-1]<dif[-2] and dif[-1]<dea[-1] and dif[-2]>dea[-2] and dif[-1]<0:\r\n        return -1\r\n    else:\r\n        return 0\r\n#6.计算DMA信号\r\ndef DMA_signal(context,bar_dict):\r\n    value = history(context.stock,['close'],200,'1d',True,'pre')\r\n    value = value.dropna()\r\n    close = value.close.values\r\n    # 计算移动均线值和差值\r\n    sma = tl.SMA(close,context.DMA_S)\r\n    lma = tl.SMA(close,context.DMA_L)\r\n    # 计算DMA\r\n    DMA = sma-lma\r\n    AMA = tl.SMA(DMA,context.DMA_M)\r\n    # 判断信号\r\n    if DMA[-1]>DMA[-2] and DMA[-1]>AMA[-1] and DMA[-2]<AMA[-2]:\r\n        return 1\r\n    elif DMA[-1]<DMA[-2] and DMA[-1]<AMA[-1] and DMA[-2]>AMA[-2]:\r\n        return -1\r\n    else:\r\n        return 0\r\n#7.计算TRIX信号\r\ndef TRIX_signal(context,bar_dict):\r\n    value = history(context.stock,['close'],300,'1d',True,'pre')\r\n    value = value.dropna()\r\n    close = value.close.values\r\n    # 计算TR\r\n    EMA1 = tl.SMA(close,context.TRIX_N)\r\n    EMA2 = tl.SMA(EMA1,context.TRIX_N)\r\n    TR = tl.SMA(EMA2,context.TRIX_N)\r\n    # 计算TRIX 和 MATTRIX\r\n    value['TR'] = TR\r\n    value['TRIX'] = value.TR/value.TR.shift(1)-1.0\r\n    TRIX = value.TRIX.values\r\n    MATTRIX = tl.SMA(TRIX,context.TRIX_M)\r\n    # 判断信号\r\n    if TRIX[-1]>TRIX[-2] and TRIX[-1]>MATTRIX[-1] and TRIX[-2]<MATTRIX[-2]:\r\n        return 1\r\n    elif TRIX[-1]<TRIX[-2] and TRIX[-1]<MATTRIX[-1] and TRIX[-2]>MATTRIX[-2]:\r\n        return -1\r\n    else:\r\n        return 0\r\n#8.计算交易信号\r\ndef stock_to_signals(context,bar_dict):\r\n    signal_1 = SMA_signal(context,bar_dict)                   #计算SMA信号\r\n    signal_2 = MACD_signal(context,bar_dict)                  #计算MACD信号\r\n    signal_3 = DMA_signal(context,bar_dict)                   #计算DMA信号\r\n    signal_4 = TRIX_signal(context,bar_dict)                  #计算TRIX信号\r\n    #返回信号值\r\n    return signal_1+signal_2+signal_3+signal_4\r\n#9.执行买卖操作\r\ndef trade_operation(signal,stock):\r\n    if signal>=1:\r\n        order_target_percent(stock,1)\r\n    if signal<=-1:\r\n        order_target_percent(stock,0)",
        "stop_run_time": "2019-01-08T14:15:50",
        "status": "SUCCESS",
        "style": "NORMAL",
        "simu_on": false,
        "strategylib": true
      },
      {
        "name": "抛物线逼近择时",
        "status": "SUCCESS",
        "id": "5c34411dac17c6000a02a94b",
        "created": "2019-01-08T14:20:13",
        "capital_base": 1000000,
        "stock_market": "STOCK",
        "modified": "2019-01-08T14:20:23",
        "start_run_time": "2019-01-08T14:20:13",
        "end_date": "2018-12-31",
        "style": "NORMAL",
        "inner": true,
        "modified_by": "hxquantdclient",
        "run_env": "py35",
        "algo_gen_method": "MANUAL",
        "frequency": "DAILY",
        "code": "'''\r\n抛物线逼近择时\r\n作者:一箩筐\r\n'''\r\n\r\n\r\nimport numpy as np\r\nimport pandas as pd\r\nimport statsmodels.api as sm\r\n\r\n\r\n# 初始化函数 ##################################################################\r\ndef init(context):\r\n    set_params(context)                      # 设置策略参数\r\n    set_variables(context)                   # 设置中间变量\r\n    set_backtest()                           # 设置回测条件\r\n#1.设置策略参数\r\ndef set_params(context):\r\n    context.stock = '600519.SH'              # 交易标的\r\n    context.N = 1                            # 信号确认日期\r\n#2.设置中间变量\r\ndef set_variables(context):\r\n    context.X_length = 1                     #抛物线累加日期\r\n    context.direct = 0                       #择时方向\r\n    context.is_change = False                #今日交易\r\n    context.Countdown = {}                   #信号确认时钟\r\n#3.设置回测条件\r\ndef set_backtest():\r\n    set_benchmark('000300.SH')               # 设置基准\r\n    set_slippage(PriceSlippage(0.002))       # 设置可变滑点\r\n\r\n\r\n# 每日开盘执行 ##################################################################\r\ndef handle_bar(context, bar_dict):\r\n    if context.X_length>2:\r\n        # 计算指标\r\n        Slope = get_signal(context,bar_dict)\r\n        # 获得交易信号\r\n        trade_signal(context,Slope)\r\n        # 执行交易\r\n        tarde_operate(context)\r\n#4.计算指标\r\ndef get_signal(context,bar_dict):\r\n    value = history(context.stock,['close','open'],context.X_length,'1d',True)\r\n    # 计算x,y\r\n    X = np.array(range(context.X_length))\r\n    X2 = X**2\r\n    c = np.ones(len(X))\r\n    Y = (value.close.values + value.open.values)/2\r\n    dic1 = {'X2':X2,'X':X,'c':c,'y':Y}\r\n    df = pd.DataFrame(dic1)\r\n    # 输入输出\r\n    x_train = df[['X','X2','c']]\r\n    y_train = df[['y']]\r\n    # 最小二乘法回归\r\n    model = sm.OLS(y_train,x_train)\r\n    results = model.fit()\r\n    #一阶斜率计算\r\n    Slope = results.params[0]+2*results.params[1]*df.X.values[-1]\r\n    log.info(Slope)\r\n    return Slope\r\n#5.获得交易信号\r\ndef trade_signal(context,Slope):\r\n    # 信号确认时钟计算\r\n    for i in context.Countdown.keys():\r\n        context.Countdown[i] -= 1\r\n        if context.Countdown[i]==0 and context.direct*Slope<0:\r\n            log.info(\"方向更改\",context.direct,Slope)\r\n            context.direct = Slope\r\n            context.is_change = True\r\n            return\r\n    # 赋予初始值，初始向上，则买入\r\n    if context.direct==0:\r\n        context.direct = Slope\r\n        if Slope>0:\r\n            order_target_percent(context.stock,1)\r\n    # 方向相反，则添加一个N天后的信号确认时钟\r\n    else:\r\n        if context.direct*Slope<0:\r\n            context.Countdown[context.X_length] = context.N\r\n#6.执行交易\r\ndef tarde_operate(context):\r\n    if context.is_change == True:\r\n        # 执行交易\r\n        if context.direct>0:\r\n            order_target_percent(context.stock,1)\r\n        if context.direct<0:\r\n            order_target_percent(context.stock,0)\r\n        # 重置中间变量\r\n        context.X_length = 1                     #抛物线累加日期\r\n        context.is_change = False                #今日交易\r\n        context.Countdown = {}                   #信号确认时钟\r\n\r\n\r\n# 每日收盘执行 ##################################################################\r\ndef after_trading(context):\r\n    context.X_length+=1",
        "simu_on": false,
        "stop_run_time": "2019-01-08T14:20:23",
        "progress": 1,
        "benchmark": "000300.SH",
        "begin_date": "2014-01-01",
        "strategylib": true
      }
    ]
  },
  {
    "folder_id": "11",
    "name": "问财策略",
    "children": [
      {
        "name": "问财日级模板",
        "modified": "2019-01-08T14:46:44",
        "stock_market": "STOCK",
        "begin_date": "2014-01-01",
        "start_run_time": "2019-01-08T14:24:03",
        "frequency": "DAILY",
        "code": "def init(context):\n    # 问句/想要选出的股票\n    buy_stocks = '小市值，低估价值股'\n    balck_stocks = 'st或停牌或上市20天内'     # 黑名单股票\n    sell_stocks = '无'                        # 卖出股票股票\n    days = 10                                 # 持仓天数\n    Max_count = 1                             # 最大持股数\n    is_hold_one = False\n    context.T_up = 0.15\n    context.T_down = - 0.3                    # 止盈止损 是否开启\n    \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    get_iwencai(buy_stocks,'want_stocks')     # 问句/想要选出的股票\n    get_iwencai(balck_stocks,'black_stocks')  # 黑名单股票\n    get_iwencai(sell_stocks,'sell_stocks')    # 卖出股票特征\n    context.days = days                       # 持仓天数\n    context.Max_count = Max_count             # 最大持股数\n    context.is_hold_one = is_hold_one         # 止盈止损 是否开启\n    context.T_up = 0.15\n    context.T_down = - 0.3\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    context.hold_days = {}   # 计时器\n    context.Cost = {}        # 买入成本\ndef handle_bar(context,bar_dict):\n    # 止盈止损\n    if context.is_hold_one == True:\n        hold_on(context,bar_dict)\n    # 日常买卖\n    operation(context,bar_dict)\ndef hold_on(context,bar_dict):\n    sell_stocks = []\n    for stock in context.positions.keys():\n        price = history(stock, ['close'], 1, '1d')['close'][-1]\n        roc = price/context.Cost[stock]-1\n        if roc>context.T_up or roc<context.T_down:\n            sell_stocks.append(stock)\n    for stock in sell_stocks:\n        order_target_value(stock,0)\n# 交易操作\ndef operation(context,bar_dict):\n    sell_stocks = []\n    for stock in list(context.portfolio.stock_account.positions.keys()):\n        # 如果在卖出股票池中则卖出\n        if stock in context.sell_stocks:\n            log.info(\"%s在卖出股票池\"%stock)\n            sell_stocks.append(stock)\n            continue\n        if stock not in context.hold_days:\n            context.hold_days[stock] = 0\n        else:\n            context.hold_days[stock] += 1\n        if context.hold_days[stock] >= context.days:\n            log.info(\"%s持仓到期卖出\"%stock)\n            sell_stocks.append(stock)\n    for stock in sell_stocks:\n        order_target_value(stock,0)\n    \n    buy_stocks = [stock for stock in context.want_stocks if stock \\\n    not in context.black_stocks]\n    Count = max([0,context.Max_count-len(list(context.portfolio.stock_account.positions.keys()))])\n    if Count>0:\n        buy_stocks = buy_stocks[:Count]\n        for stock in buy_stocks:\n            order_percent(stock,1/context.Max_count)\n            context.hold_days[stock] = 0\n            h = history(stock, ['close'], 1, '1d')['close'][-1]\n            context.Cost[stock] = h",
        "stop_run_time": "2019-01-08T14:46:44",
        "progress": 1,
        "id": "5c34420375019f000ae544ad",
        "capital_base": 1000000,
        "end_date": "2018-12-31",
        "created": "2019-01-08T14:24:03",
        "run_env": "py35",
        "algo_gen_method": "MANUAL",
        "style": "NORMAL",
        "status": "SUCCESS",
        "inner": true,
        "simu_on": false,
        "strategylib": true
      },
      {
        "name": "问财分钟模板",
        "algo_gen_method": "MANUAL",
        "inner": true,
        "stock_market": "STOCK",
        "modified": "2018-12-25T14:47:24",
        "begin_date": "2018-01-01",
        "created": "2018-12-25T13:30:12",
        "simu_on": false,
        "style": "NORMAL",
        "progress": 1,
        "frequency": "MINUTE",
        "status": "SUCCESS",
        "end_date": "2018-12-24",
        "capital_base": 1000000,
        "stop_run_time": "2018-12-25T14:47:24",
        "code": "# 爱问财策略回测框架（分钟级回测）\r\n\r\nimport datetime\r\n\r\n# 初始化账户\r\ndef init(context):\r\n    # 设置策略问句\r\n    get_iwencai('非停牌;非st;业绩预增大于50%；市值排名后30%；市盈率小于120；总市值从小到大')\r\n    # 设置持仓股票数量\r\n    context.n = 4\r\n    # 设置股票持有期\r\n    context.holding_period = 5\r\n    # 设置止盈涨幅\r\n    context.stop_gain = 0.2\r\n    # 设置止盈回撤\r\n    context.stop_gain_drawdown = 0.05\r\n    # 设置止损跌幅\r\n    context.stop_loss = 0.05\r\n    # 设置仓位比例\r\n    context.position_pct = 1\r\n    \r\n    context.information = {}\r\n    \r\n    run_daily(market_open,'after_open',0,1,'000001.SZ')\r\n    run_daily(market_close,'before_close',0,5,'000001.SZ')\r\n    \r\n\r\nclass Information:\r\n    # 记录买入股票的信息，作为position的补充\r\n    def __init__(self, remain_days):\r\n        self.remain_days = remain_days\r\n        self.stop_gain = False\r\n        self.today_high = 0\r\n\r\n# 开盘时买入股票\r\ndef market_open(context, bar_dict):\r\n    # 若持有天数到期则卖出（防止昨天未卖出）\r\n    for stock in list(context.portfolio.positions):\r\n        context.information[stock].today_high = 0\r\n        if (not context.information[stock].stop_gain\r\n                and context.information[stock].remain_days == 0):\r\n            order_target(stock, 0)\r\n            if stock not in list(context.portfolio.positions):\r\n                del context.information[stock]\r\n                log.info('持有天数到期，卖出%s' % stock)\r\n                continue\r\n    \r\n    stocks_list = context.iwencai_securities\r\n    number_of_buys = context.n-len(context.portfolio.positions)\r\n    if number_of_buys == 0:\r\n        return\r\n    # 若持有股数不足设定值则买入\r\n    cash_for_stock = context.portfolio.available_cash*context.position_pct/number_of_buys\r\n    \r\n    for stock in stocks_list:\r\n        if stock in context.portfolio.positions:\r\n            continue\r\n        #current = data.current([stock])[stock]\r\n        if not bar_dict[stock].open or not bar_dict[stock].close:\r\n            continue\r\n        # 开盘涨跌幅不小于-9%才买入\r\n        if bar_dict[stock].open/bar_dict[stock].close-1 >= -0.09:\r\n            order_value(stock, cash_for_stock)\r\n            if stock in list(context.portfolio.positions):\r\n                context.information[stock] = Information(context.holding_period)\r\n                log.info('买入%s' % stock)\r\n        number_of_buys -= 1\r\n        if number_of_buys == 0:\r\n            return\r\n\r\n# 盘中止盈止损\r\ndef handle_bar(context, bar_dict):\r\n    price_dict = history(list(context.portfolio.positions), ['close'], 2, '1m')\r\n    for stock in price_dict:\r\n        if price_dict[stock].empty:\r\n            continue\r\n        price = price_dict[stock].values[-1][0]\r\n        # 更新今日最高价\r\n        if price > context.information[stock].today_high:\r\n            context.information[stock].today_high = price\r\n        # 若刚买入则不进行操作\r\n        if context.information[stock].remain_days == context.holding_period:\r\n            continue\r\n        # 若进入止盈状态，则根据要求止盈\r\n        if context.information[stock].stop_gain:\r\n            if price/context.information[stock].high-1 < -context.stop_gain_drawdown:\r\n                order_target(stock, 0)\r\n                if stock not in context.portfolio.positions:\r\n                    del context.information[stock]\r\n                    log.info('止盈，卖出%s' % stock)\r\n        # 若未进入止盈状态，则根据要求止损\r\n        else:\r\n            if price/context.portfolio.positions[stock].cost_basis-1 < -context.stop_loss:\r\n                order_target(stock, 0)\r\n                if stock not in context.portfolio.positions:\r\n                    del context.information[stock]\r\n                    log.info('止损，卖出%s' % stock)\r\n\r\n# 收盘时卖出到期股票、判断止盈\r\ndef market_close(context, bar_dict):\r\n    for stock in list(context.portfolio.positions):\r\n        today_high = context.information[stock].today_high\r\n        # 若进入止盈状态，则更新最高价\r\n        if context.information[stock].stop_gain:\r\n            if today_high > context.information[stock].high:\r\n                context.information[stock].high = today_high\r\n        # 若未进入止盈状态，则卖出到期股票、判断止盈\r\n        else:\r\n            # 判断是否进入止盈状态\r\n            if today_high/context.portfolio.positions[stock].cost_basis-1 >= context.stop_gain:\r\n                context.information[stock].stop_gain = True\r\n                context.information[stock].high = today_high\r\n                log.info('%s进入止盈状态' % stock)\r\n                continue\r\n            # 若持有天数到期则卖出\r\n            context.information[stock].remain_days -= 1\r\n            if context.information[stock].remain_days == 0:\r\n                order_target(stock, 0)\r\n                if stock not in context.portfolio.positions:\r\n                    del context.information[stock]\r\n                    log.info('持有天数到期，卖出%s' % stock)\r\n                    continue",
        "run_env": "py35",
        "id": "5c21c0645e1f06000ca63f2a",
        "start_run_time": "2018-12-25T13:30:12",
        "strategylib": true
      }
    ]
  }
]
